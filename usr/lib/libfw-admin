#!/bin/bash

# Arturo Borrero <aborrero@cica.es> Marzo/Abril/Mayo/Junio/Julio 2012

################################################################
################################################################
# Variables
################################################################
################################################################
VERSION="0.3.3"
PID=$$
THIS="`uname -n`"

IPSET="/usr/sbin/ipset"
IPT="/sbin/iptables"
IP6T="/sbin/ip6tables"
IPSET_LOCAL="/usr/sbin/ipset"
IPT_LOCAL="/sbin/iptables"
IP6T_LOCAL="/sbin/ip6tables"
IPSET_CLUSTER="/usr/sbin/ipset-cluster"
IPT_CLUSTER="/usr/sbin/iptables-cluster"
IP6T_CLUSTER="/usr/sbin/ip6tables-cluster"
IPT_SAVE="/sbin/iptables-save"
IP6T_SAVE="/sbin/ip6tables-save"
CONNTRACKD="/usr/sbin/conntrackd"
CONNTRACK="/usr/sbin/conntrack"
DIG="/usr/bin/dig"

AUX_FILE="`mktemp`"

EJECUTABLE_LOGGER="/usr/bin/logger"
ARGS_LOGGER="-t fw-admin[$PID] --"

################################################################
################################################################
# Funciones
################################################################
################################################################

# void message(string message)
# Esta funcion pinta un mensaje por pantalla y quizás lo guarde en un log
message()
{

	# En el fichero /etc/fw-admin.conf puede configurarse
	# que se muestren colores aqui o no.
	# Se sustituiran las cadenas por la misma cadena con el código del color.
	if [ "$USE_COLORS" == "yes" ]
	then
		echo -e $1 | sed s/"E:"/`echo -en ${C_RED}E:${C_NORMAL}`/ | sed s/"W:"/`echo -en ${C_YELLOW}W:${C_NORMAL}`/ | sed s/"I:"/`echo -en ${C_GREENBOLD}I:${C_NORMAL}`/
	else
		echo -e $1
	fi

	# solo se logean mensajes de error y warning
	[ "$LOG_ERROR_MESSAGES" == "yes" ] && [[ $1 =~ ^"E:" ]] && $EJECUTABLE_LOGGER $ARGS_LOGGER $1
	[ "$LOG_WARN_MESSAGES" == "yes" ] && [[ $1 =~ ^"W:" ]] && $EJECUTABLE_LOGGER $ARGS_LOGGER $1
}

# void do_exit(int exit_code)
# sale del programa borrando el lockfile y el fichero auxiliar
do_exit()
{
	if [ -r $LOCK_FILE ]
	then
		if [ "`cat $LOCK_FILE`" == "${$}@${THIS}" ] 2> /dev/null # Borramos el lock file solo si es nuestro
		then
			rm -f $LOCK_FILE 2> /dev/null
		fi
	fi
	if [ -e $AUX_FILE ]
	then
		rm -f $AUX_FILE 2> /dev/null
	fi
	exit $1
}

# boolean validar_ejecucion()
# valida que no hay dos instancias de fw-admin en operacion critica
validar_ejecucion() # Incluye punto de salida
{
	# Si no existe el lock file
	# la ejecucion es nuestra, guardar nuestro pid
	if [ ! -r $LOCK_FILE ]
	then
		echo "${$}@${THIS}" > $LOCK_FILE 2> /dev/null
	fi

	local pid=`cat $LOCK_FILE`
	if [ "$pid" != "${$}@${THIS}" ] 2> /dev/null
	then
		message "E: Parece que ya hay una instancia en ejecucion. Existe lockfile [${LOCK_FILE}] con pid [${pid}]. Terminando..."
		do_exit 1
	fi
	return 0
}

# boolean is_ipv4_valid(string ipv4)
# Check if an ipv4 is a valid ipv4
is_ipv4_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		egrep '^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$' <<< $1 > /dev/null
		if [ $? -eq 0 ]
		then
			retval=0
		fi
	fi
	return $retval
}

# boolean is_ipv6_valid(string ipv6)
# Check if an ipv6 is a valid ipv6
is_ipv6_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		egrep -E '^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:)))(%.+)?\s*$' <<< $1 > /dev/null
		if [ $? -eq 0 ]
		then
			retval=0
		fi
	fi
	return $retval
}

# boolean is_fqdn_valid(string fqdn)
# Check if an fqdn is a valid fqdn
is_fqdn_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		# resolve it to know if it's valid
		if [ `$DIG +short $1 | wc -l` -ne 0 ] > /dev/null
		then
			retval=0
		fi
	fi
	return $retval
}

# boolean is_ip_fqdn_valid(string ip_or_fqdn)
# Check if an address is valid (ip or fqdn)
is_ip_fqdn_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		# Es posible que tengamos una ipv4, una ipv6 o un fqdn
		is_ipv6_valid $1 && retval=0
		is_ipv4_valid $1 && retval=0
		is_fqdn_valid $1 && retval=0
	fi
	return $retval
}

# boolean is_domain_fqdn(string fqdn)
# Funcion que valora si un fqdn es del dominio cica.es
is_domain_fqdn()
{
	local retval=1
	grep "$DOMAIN"$ <<< $1 > /dev/null
	if [ $? -eq 0 ]
	then
		retval=0
	fi
	return $retval
}

# Esta funcion checkea que quien ejecuta es root
check_root()
{
	local retval=0
	if [ `id -u` -ne 0 ]
	then
		message "E: No eres root!"
		retval=1
	fi
	return $retval
}

# Esta funcion checkea y avisa de todos los ficheros necesarios para esta ejecucion
check_files()
{
	local retval=0
	[ -x $IPT_SAVE ] || { message "E: Incapaz de acceder a [$IPT_SAVE]" ; retval=1 ; }
	[ -x $IP6T_SAVE ] || { message "E: Incapaz de acceder a [$IP6T_SAVE]" ; retval=1 ; }
	[ -w $AUX_FILE ] || { message "E: Fallo al crear el fichero auxiliar [$AUX_FILE]" ; retval=1 ; }
	[ -d $CONF_DIR ] || { message "E: Incapaz de acceder al directorio [$CONF_DIR]" ; retval=1 ; }
	[ -x $IPSET_CONF ] || { message "E: Incapaz de acceder al fichero [$IPSET_CONF]" ; retval=1 ; }
	[ -d $DATA_DIR ] || { message "E: Incapaz de acceder al directorio [$DATA_DIR]" ; retval=1 ; }
	[ -w $VARS_IPV6 ] || { message "E: Incapaz de acceder al fichero [$VARS_IPV6]" ; retval=1 ; }
	[ -w $VARS_IPV4 ] || { message "E: Incapaz de acceder al fichero [$VARS_IPV4]" ; retval=1 ; }
	[ -w $VARS_IPSETV6 ] || { message "E: Incapaz de acceder al fichero [$VARS_IPSETV6]" ; retval=1 ; }
	[ -w $VARS_IPSETV4 ] || { message "E: Incapaz de acceder al fichero [$VARS_IPSETV4]" ; retval=1 ; }
	[ -x $IPT ] || { message "E: El binario [$IPT] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }
	[ -x $IP6T ] || { message "E: El binario [$IP6T] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }
	[ -x $IPSET ] || { message "E: El binario [$IPSET] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }
	[ -x $CONNTRACKD ] || { message "E: El binario [$CONNTRACKD] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }
	[ -x $DIG ] || { message "E: El binario [$DIG] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }

	# Only if neccesary
	if [ "$USE_IPTABLES_CLUSTER" == "yes" ]
	then
		[ -x $IPT_CLUSTER ] || { message "E: El binario [$IPT_CLUSTER] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }
		[ -x $IP6T_CLUSTER ] || { message "E: El binario [$IP6T_CLUSTER] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }
		[ -x $IPSET_CLUSTER ] || { message "E: El binario [$IPSET_CLUSTER] no tiene permisos de ejecucion o no se ha encontrado." ; retval=1 ; }
	fi

	return $retval
}


# Esta funcion retorna el nombre que debe de tener la variable en funcion de su valor
obtener_nombre_variable()
{
	# Usamos una variable global, llamada "nombre_variable"
	if [ ! -z $1 ]
	then
		# El parametro de entrada no esta vacio
		is_ipv4_valid $1 && { nombre_variable=`echo v$1 | tr '.' '_'` ; return 0 ; }
		is_ipv6_valid $1 && { nombre_variable=`echo v$1 | tr ':' '_'` ; return 0 ; }
		if is_fqdn_valid $1
		then
			# Es una variable fqdn
			if is_domain_fqdn $1
			then
				# Es un fqdn de CICA, la variable no tendra el dominio
				nombre_variable=`echo $1 | awk -F".$DOMAIN" '{print $1}'| tr [:lower:] [:upper:] | tr '.' '_' | tr '-' '_'`
			else
				# No es un fqdn de CICA
				nombre_variable=`echo $1 | tr [:lower:] [:upper:] | tr '.' '_' | tr '-' '_'`
			fi
		fi
	else
		message "E: Se ha producido un error al calcular el nombre que debe tener la variable."
		do_exit 1
	fi
	return 0

}

# ip get_ip_from_fqdn(string tipo_ip, string fqdn)
get_ip_from_fqdn()
{
        local tipo_ip=$1
        local fqdn=$2

	[ -z "$tipo_ip" ] && { message "E: En la funcion get_ip_from_fqdn() (recursiva) llamada con parametro tipo_ip vacio." ; do_exit 1 ; }
	[ -z "$fqdn" ] && { message "E: En la funcion get_ip_from_fqdn() (recursiva) llamada con parametro fqdn vacio." ; do_exit 1 ; }

        local resolucion=`$DIG +short $fqdn $tipo_ip`
        if is_ipv6_valid $resolucion
        then
                echo "$resolucion" #punto de salida
        else
		if is_ipv4_valid $resolucion
		then
			echo "$resolucion" #punto de salida
		else
			oldIFS=$IFS
			IFS=$' \t\n'
	                for linea in $resolucion
	                do
	                        local resolucion2="$resolucion2 $(get_ip_from_fqdn $tipo_ip $linea)"
	                done
			IFS=$oldIFS
	                local resolucion3=`echo "$resolucion2" | tr [[:space:]] '\n' | grep -v ^[[:space:]]*$ | sort -u | uniq`
	                echo "$resolucion3" #punto de salida
		fi
        fi
	return 0
}

# Esta funcion recorre todas las variables del sistema, reajustando su valor.
recargar_variables()
{
	local recargar_variables_retval=0
	echo "" > $AUX_FILE

	message "I: No se recargan variables que contengan \"##ignorar##\"."
	local lista_variables=`{ cat $VARS_IPV4 ; cat $VARS_IPV6 ; } | egrep -v "##ignorar##"\|"@"\|^[[:space:]]*# \
		| awk -F'#' '{print $2}' | sort -u | uniq | grep -v ^[[:space:]]*$`
	oldIFS=$IFS
        IFS=$' \t\n'
	local total=`wc -w <<< $lista_variables`
	local cont=0
	for variable in $lista_variables
	do
		((cont++))
		lib_progress_bar -d 2 -m 55 $cont $total
		# Solo se mostraran luego los mensajes de error
		agregar_variable $variable | grep E: >> $AUX_FILE || recargar_variables_retval=1
	done
	IFS=$oldIFS
	message "I: Resultados:"
	cat $AUX_FILE
	return $recargar_variables_retval
}

# Funcion que agrega una variable al sistema, IPv4, IPv6 o FQDN.
# Puede ser llamada con o sin parametro de entrada con prompt.
agregar_variable()
{
	# trap de cancelacion
	trap " echo "" && message \"W: Interrumpiendo...\" && do_exit 1 " SIGHUP SIGINT SIGTERM SIGKILL SIGTSTP SIGQUIT SIGCONT

	local agregar_variable_retval=0
	local dato_a_agregar=$1
	local flag_es_ipv4=0
	local flag_es_ipv6=0
	local flag_es_fqdn=0

	if [ -z $dato_a_agregar ]
	then
		# No hay parametro de entrada, usar menu
		read -p "-> Definir IPv4, IPv6 o FQDN: " dato_a_agregar
	fi

	#
	# Validacion del dato introducido (por parametro o prompt)
	#

	{ is_ipv4_valid $dato_a_agregar || is_ipv6_valid $dato_a_agregar || is_fqdn_valid $dato_a_agregar ; } \
		|| { message "E: No se ha reconocido en [${dato_a_agregar}] una IP o FQDN que pueda usarse." ; agregar_variable_retval=1 ; }


	# Procedemos solo si se ha validado el parametro
	if [ $agregar_variable_retval -eq 0 ]
	then

		#
		# Obtener nombre definitivo que tendra la variable
		#

		nombre_variable="" #variable global usada por obtener_nombre_variable()
		obtener_nombre_variable $dato_a_agregar
		echo "DEBUG: $nombre_variable=$dato_a_agregar #$dato_a_agregar" > /dev/null

		if grep ^"${nombre_variable}=" $VARS_IPV4 > /dev/null 2> /dev/null && grep ^"${nombre_variable}=" $VARS_IPV6 > /dev/null 2> /dev/null
		then
			# La variable ya esta guardada, actualizar
			message "W: Actualizando la variable [${nombre_variable}]."
		else
			message "I: El nombre de la variable es [${nombre_variable}]."
		fi

		#
		# Escribir las variables a los ficheros de datos
		#
		guardar_variable_en_fichero "ipv4" "$nombre_variable" "$dato_a_agregar" \
			|| { message "E: fallo al guardar la variable al fichero [${VARS_IPV4}]" ; agregar_variable_retval=1 ; }
		guardar_variable_en_fichero "ipv6" "$nombre_variable" "$dato_a_agregar" \
			|| { message "E: fallo al guardar la variable al fichero [${VARS_IPV6}]" ; agregar_variable_retval=1 ; }

		#
		# Checkeo de que la escritura ha sido correcta
		#
		grep ^"${nombre_variable}=" $VARS_IPV4 > /dev/null 2> /dev/null || agregar_variable_retval=1
		grep ^"${nombre_variable}=" $VARS_IPV6 > /dev/null 2> /dev/null || agregar_variable_retval=1
		[ $agregar_variable_retval -ne 0 ] &&  message "E: No se pudo guardar la variable [${nombre_variable}]."
	fi
	return $agregar_variable_retval

}

# Funcion que agrega una variable IPSET al sistema
# Puede ser llamada con o sin parametro de entrada con prompt.
agregar_set()
{
	local agregar_set_retval=0
	local dato_a_agregar=$1

	if [ -z $dato_a_agregar ]
	then
		# No hay parametro de entrada, usar menu
		read -p "-> Definir nombre del conjunto (algo como W_ALL o S_NIS): " dato_a_agregar
	fi

	#
	# Validacion del dato introducido (por parametro o prompt)
	#
	# Mayusculas
	dato_a_agregar=`tr [:lower:] [:upper:] <<< $dato_a_agregar`
	# No debe existir
	( grep -i "${dato_a_agregar}_ipv4" $VARS_IPSETV4 > /dev/null && grep -i "${dato_a_agregar}_ipv6" $VARS_IPSETV6 > /dev/null ) \
		&& { message "E: La variable ya existe." ; agregar_set_retval=1 ; }

	# Procedemos solo si se ha validado el parametro
	if [ $agregar_set_retval -eq 0 ]
	then
		#
		# Escribir las variables a los ficheros de datos
		#
		echo "$dato_a_agregar=`tr [:upper:] [:lower:] <<< $dato_a_agregar`_ipv4" >> $VARS_IPSETV4 \
				|| { message "E: Fallo al escribir la variable en [$VARS_IPSETV4]" ; agregar_set_retval=1 ; }
		echo "$dato_a_agregar=`tr [:upper:] [:lower:] <<< $dato_a_agregar`_ipv6" >> $VARS_IPSETV6 \
				|| { message "E: Fallo al escribir la variable en [$VARS_IPSETV6]" ; agregar_set_retval=1 ; }

		echo "Los datos guardados: "
		grep ^"${dato_a_agregar}=" $DATA_DIR/* 2>/dev/null
	fi


	return $agregar_set_retval
}


# Esta funcion recibe tres parametros: {ipv4|ipv6} {variable} {dato}
# y guarda en el fichero correspondiente
guardar_variable_en_fichero()
{
	local guardar_variable_en_fichero_retval=0
	local ip=$1
	local nombre_variable=$2
	local dato_a_agregar=$3

	if [ -z $nombre_variable ]
	then
		guardar_variable_en_fichero_retval=1
	fi
	if [ -z $dato_a_agregar ]
	then
		guardar_variable_en_fichero_retval=1
	fi
	# Eligiendo el fichero donde trabajaremos
	if [ $ip = "ipv4" ]
	then
		local fichero_trabajo=$VARS_IPV4
	else
		if [ $ip = "ipv6" ]
		then
			local fichero_trabajo=$VARS_IPV6
		else
			guardar_variable_en_fichero_retval=1
		fi
	fi
	# Punto de salida
	if [ $guardar_variable_en_fichero_retval -ne 0 ]
	then
		message "E: Fallo al llamar a la funcion [guardar_variable_en_fichero()] Parametros de entrada invalidos."
		return $guardar_variable_en_fichero_retval
	fi

	# Borrando posible dato anterior
	if grep ^"${nombre_variable}=" $fichero_trabajo > /dev/null
	then
		local datos=`grep -v ^"${nombre_variable}=" $fichero_trabajo | grep -v ^[[:space:]]*$`
		echo "$datos" > $fichero_trabajo
		[ $? -ne 0 ] && { message "E: Fallo al borrar el dato anterior en la actualizacion. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
	fi

	[ $guardar_variable_en_fichero_retval -ne 0 ] && return $guardar_variable_en_fichero_retval # punto de retorno

	# Como guardar los datos si estamos trabajando con un FQDN
	if is_fqdn_valid $dato_a_agregar
	then
		case "$ip" in
			"ipv4" )
				#tirar del hilo
				local resolucion="$(get_ip_from_fqdn A $dato_a_agregar)"
				;;
			"ipv6" )
				#tirar del hilo
				local resolucion="$(get_ip_from_fqdn AAAA $dato_a_agregar)"
				;;
		esac
		if [ -z "$resolucion" ]
		then
			# No hay resolucion DNS para este registro
			echo "${nombre_variable}=\$FICTICIA #$dato_a_agregar" >> $fichero_trabajo
			[ $? -ne 0 ] && { message "E: Fallo al agregar dato [${dato_a_agregar}] ficticio a [$fichero_trabajo]. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
		else
			# Hay resolucion DNS para el registro
			if [ `echo "$resolucion" | wc -l` -gt 1 ]
			then
				# Resolucion compleja de este registro
				echo "${nombre_variable}=${dato_a_agregar} #$dato_a_agregar" >> $fichero_trabajo
				[ $? -ne 0 ] && { message "E: Fallo al agregar dato [${dato_a_agregar}] de resolucion compleja a [$fichero_trabajo]. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
			else
				# Resolucion normal de este registro
				echo "${nombre_variable}=$resolucion #$dato_a_agregar" >> $fichero_trabajo
				[ $? -ne 0 ] && { message "E: Fallo al agregar dato [${dato_a_agregar}] de resolucion normal a [$fichero_trabajo]. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
			fi
		fi
	else # dato de IP cruda (v4 o v6)
		# Como guardar los datos si estamos trabajando con una IPv6
		if is_ipv6_valid $dato_a_agregar
		then
			case "$ip" in
				"ipv4" )
					echo "${nombre_variable}=\$FICTICIA #$dato_a_agregar" >> $fichero_trabajo
					[ $? -ne 0 ] && { message "E: Fallo al agregar dato [${dato_a_agregar}] ficticio a [$fichero_trabajo]. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
					;;
				"ipv6" )
					echo "${nombre_variable}=${dato_a_agregar} #$dato_a_agregar" >> $fichero_trabajo
					[ $? -ne 0 ] && { message "E: Fallo al agregar dato [${dato_a_agregar}] ficticio a [$fichero_trabajo]. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
					;;
			esac
		else
			# Como guardar los datos si estamos trabajando con una IPv4
			if is_ipv4_valid $dato_a_agregar
			then
				case "$ip" in
					"ipv4" )
						echo "${nombre_variable}=${dato_a_agregar} #$dato_a_agregar" >> $fichero_trabajo
						[ $? -ne 0 ] && { message "E: Fallo al agregar dato [${dato_a_agregar}] ficticio a [$fichero_trabajo]. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
						;;
					"ipv6" )
						echo "${nombre_variable}=\$FICTICIA #$dato_a_agregar" >> $fichero_trabajo
						[ $? -ne 0 ] && { message "E: Fallo al borrar el dato anterior en la actualizacion. Posible perdida de datos." ; guardar_variable_en_fichero_retval=1 ; }
						;;
				esac
			else
				message "E: Funcion [guardar_datos_a_ficheros()] mal llamada: El dato no se ha detectado como valido."
				guardar_variable_en_fichero_retval=1
			fi
		fi
	fi
	return $guardar_variable_en_fichero_retval
}

# Esta funcion genera estadisticas cuando es llamada mediante `fw-admin -s'
estadisticas()
{
	local retval=0

	# Info iptables
	echo "### Información sobre iptables"
	local reglas_ipv4=`$IPT_SAVE 2>/dev/null | grep ^- 2>/dev/null | wc -l`
	local reglas_ipv6=`$IP6T_SAVE 2>/dev/null | grep ^- 2>/dev/null | wc -l`
	echo " Reglas IPv4: $reglas_ipv4"
	echo " Reglas IPv6: $reglas_ipv6"
	echo " Total de reglas: `expr $reglas_ipv4 + $reglas_ipv6`"
	local reglas_no_usadas_ipv4=`$IPT -L -n -v 2>/dev/null | egrep -v "Chain"\|"pkts bytes" | grep -v ^[[:space:]]*$ | grep ^[[:space:]]*0 | wc -l`
	local reglas_no_usadas_ipv6=`$IP6T -L -n -v 2>/dev/null | egrep -v "Chain"\|"pkts bytes" | grep -v ^[[:space:]]*$ | grep ^[[:space:]]*0 | wc -l`
	echo " Reglas no usadas en IPv4: $reglas_no_usadas_ipv4"
	echo " Reglas no usadas en IPv6: $reglas_no_usadas_ipv6"
	echo " Uso y politica en IPv4:"
	$IPT -n -L -v 2>/dev/null | grep policy | while read linea
	do
		echo -e "\t$linea"
	done
	echo " Uso y politica en IPv6:"
	$IP6T -n -L -v 2>/dev/null | grep policy | while read linea
	do
		echo -e "\t$linea"
	done
	echo " Hash de las reglas del kernel: `( { $IPT_SAVE 2>/dev/null ; $IP6T_SAVE 2>/dev/null; } | grep ^"-" | md5sum | awk -F' ' '{print $1}' ) || echo error! `"
	echo ""

	# Info ipset
	echo "### Información sobre ipset"
	local total_sets="`$IPSET -L -n 2>/dev/null | wc -l`"
	echo " Sets en el kernel: $total_sets"
	local sets_usados="`$IPSET list 2>/dev/null | grep \"References: \" | grep -v \"References: 0\" | wc -l`"
	echo " Sets usados en el kernel: $sets_usados"
	local sets_no_usados=`$IPSET list 2>/dev/null | grep "References: 0" | wc -l`
	echo " Sets no usados en el kernel: $sets_no_usados"
	echo ""

	# Info conntrackd
	echo "### Estadisticas de Conntrackd"
	$CONNTRACKD -s 2> /dev/null | while read linea
	do
		echo -n " " ; echo "$linea"
	done || message "E: Al consultar las estadisticas de conntrackd."

	# Info variables
	echo "### Otras estaditisticas"
	local vars_ipv4=`grep \= $VARS_IPV4 2>/dev/null | wc -l`
	local vars_ipv6=`grep \= $VARS_IPV6 2>/dev/null | wc -l`
	echo " Variables IPv4 declaradas: $vars_ipv4"
	echo " Variables IPv6 declaradas: $vars_ipv6"
	if [ $vars_ipv4 -ne $vars_ipv6 ]
	then
		message " W: Los ficheros de IPs o FQDNs pueden estar corruptos; el numero de variables declaradas no coinciden!"
	fi
	local vars_ipset_ipv4=`grep \= $VARS_IPSETV4 2>/dev/null | wc -l`
	local vars_ipset_ipv6=`grep \= $VARS_IPSETV6 2>/dev/null | wc -l`
	echo " Variables IPSET IPv4 declaradas: $vars_ipset_ipv4"
	echo " Variables IPSET IPv6 declaradas: $vars_ipset_ipv6"
	if [ $vars_ipset_ipv4 -ne $vars_ipset_ipv6 ]
	then
		message " W: Los ficheros de variables de IPSET pueden estar corruptos; el numero de variables declaradas no coinciden!"
	fi
	[[ $MINIMAL_AMOUNT_OF_RULES =~ ^[0-9]+$ ]] || MINIMAL_AMOUNT_OF_RULES=40
	if [ $reglas_ipv4 -gt $MINIMAL_AMOUNT_OF_RULES ] || [ $reglas_ipv6 -gt $MINIMAL_AMOUNT_OF_RULES ]
	then
		echo " El firewall parece activo (Más de $MINIMAL_AMOUNT_OF_RULES reglas)."
	fi
	return $retval

}

# Esta funcion se usa desde la funcion obtener informacion
# Recibe una cadena de texto a buscar, un fichero a donde escribir el mensaje
# Retorna 1 si ha operado bien
buscar_en_fichero()
{
	local dato=$1 #dato a buscar
	local fichero=$2 #fichero al que escribir mensaje en caso de acierto

	if [ ! -z "$dato" ] && [ -e "$fichero" ]
	then
		grep "$dato" $VARS_IPV4 | while read linea # Se recorren cada una de las lineas que pudiera devolver el grep
		do
			# Si cambias este message debes cambiar la funcion obtener_informacion()
			echo -e "Dato relacionado en ${C_BOLD}$VARS_IPV4${C_NORMAL} de la forma: ${C_BOLD} $linea ${C_NORMAL}" >> $2
		done
		grep "$dato" $VARS_IPV6 | while read linea # Se recorren cada una de las lineas que pudiera devolver el grep
		do
			# Si cambias este mensaje debes cambiar la funcion obtener_informacion()
			echo -e "Dato relacionado en ${C_BOLD}$VARS_IPV6${C_NORMAL} de la forma: ${C_BOLD} $linea ${C_NORMAL}" >> $2
		done
	fi
}

# Funcion obtener informacion. Recibe de entrada una cadena.
obtener_informacion()
{
	oldIFS=$IFS
        IFS=$' \t\n'

	local obtener_informacion_retval=1
        local dato_consulta=$1
	echo -n "" > $AUX_FILE

        if [ -z $dato_consulta ]
        then
                # No hay parametro de entrada, usar menu
                read -p "-> Definir IPv4, IPv6 o FQDN: " dato_consulta
        fi

	# Buscar en ficheros: se le pasa como parametros el dato a buscar y el fichero donde debe escribir el mensaje
	# Retorna 1 en caso de acierto

	# 1º Busqueda es por el dato introducido en crudo
	buscar_en_fichero $dato_consulta $AUX_FILE

	nombre_variable=""
	obtener_nombre_variable $dato_consulta

	if [ ! -z $nombre_variable ]
	then
		# 2º Busqueda es por el posible nombre variable que pudiera tener el dato introducido
		buscar_en_fichero $nombre_variable $AUX_FILE
	fi

	# 3º busqueda se realiza si ya se ha encontrado algun dato, por un nombre de variable o de aclaracion (tras #) similar
	# Ojo al formato que hace la funcion buscar_en_fichero()
	# "Dato relacionado en ${C_BOLD}$VARS_IPV4${C_NORMAL} de la forma: ${C_BOLD}$dato_guardado${C_NORMAL}" # ojo ' VAR=dato #aclaracion'
	if [ `cat $AUX_FILE | wc -l` -gt 0 ]
	then

		# Buscando por aclaracion (tras #)
		local nueva_lista_datos_busqueda=`cat $AUX_FILE | awk -F'#' '{print $2}' | awk -F' ' '{print $1}' | sort -u | uniq `
		for i in $nueva_lista_datos_busqueda
		do
			buscar_en_fichero $i $AUX_FILE
		done
		# Buscando por variable (antes de = )
		local nueva_lista_datos_busqueda=`cat $AUX_FILE | awk -F' ' '{print $9}' | awk -F'=' '{print $1}' | sort -u | uniq`
		for i in $nueva_lista_datos_busqueda
		do
			buscar_en_fichero $i $AUX_FILE
		done
		# Buscando por variable (despues de = )
		local nueva_lista_datos_busqueda=`cat $AUX_FILE | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | sort -u | uniq`
		for i in $nueva_lista_datos_busqueda
		do
			if [ "$i" != "\$FICTICIA" ]
			then
				buscar_en_fichero $i $AUX_FILE
			fi
		done
	fi

	local lista_de_set_con_coincidencias=""
	# Realizar la consulta en IPset: dato o variable guardada
	if [ `cat $AUX_FILE | wc -l` -gt 0 ]
	then
		if [ ! -z "$nombre_variable" ]
		then
			busqueda_ipset=`egrep $nombre_variable\|$dato_consulta $DATA_DIR/* | awk -F'#' '{print $2}' | sort -u | uniq`
		else
			busqueda_ipset=`grep $dato_consulta $DATA_DIR/* | awk -F'#' '{print $2}' | sort -u | uniq`
		fi
		echo DEBUG: $busqueda_ipset > /dev/null
		local lista_sets=`$IPSET -L | grep "Name:" | awk -F' ' '{print $2}' | grep -v ^[[:space:]]*$`
		for un_set in $lista_sets
		do
			$IPSET -T $un_set $busqueda_ipset > /dev/null 2> /dev/null
			if [ $? -eq 0 ]
			then
				lista_de_set_con_coincidencias="$lista_de_set_con_coincidencias $un_set"
			fi
		done
	fi

	# Realizar la consulta en IPset: dato en crudo
	local lista_sets=`$IPSET -L | grep "Name:" | awk -F' ' '{print $2}' | grep -v ^[[:space:]]*$`
	for un_set in $lista_sets
	do
		$IPSET -T $un_set $dato_consulta > /dev/null 2> /dev/null
		if [ $? -eq 0 ]
		then
			lista_de_set_con_coincidencias="$lista_de_set_con_coincidencias $un_set"
		fi
	done

	# Mostrar o no set donde se han encontrado datos
	if [ ! -z "$lista_de_set_con_coincidencias" ]
	then
		# Arreglar para mostrar por pantalla la lista de sets
		lista_de_set_con_coincidencias=`echo $lista_de_set_con_coincidencias | tr ' ' '\n' | grep -v ^[[:space:]]*$ | sort -u | uniq | tr '\n' ' '`
		echo -e "I: El dato ${C_BOLD}$dato_consulta${C_NORMAL} esta reflejado en el/los set: [${lista_de_set_con_coincidencias}]" >> $AUX_FILE
		flag_datos_mostrados=1
	fi


	#########################################################
	# Ordenando y mostrando los datos que tenemos hasta ahora
	if [ `cat $AUX_FILE | wc -l` -ne 0 ]
	then
		flag_datos_mostrados=true
		cat $AUX_FILE | sort -u | while read linea
		do
			message "$linea"
		done
	fi

	echo -n "" > $AUX_FILE
	# Si habia set coincidente, mostrar ahora las reglas para ese set
	if [ ! -z "$lista_de_set_con_coincidencias" ]
	then
		message "I: Reglas que hacen referencias a los sets relacionados:"
		oldIFS=$IFS ; IFS=$' '
		for i in $lista_de_set_con_coincidencias
		do
			$IPT_SAVE -c | grep "match\-set" | grep "$i" >> $AUX_FILE
			$IP6T_SAVE -c | grep "match\-set" | grep "$i" >> $AUX_FILE
		done
		IFS=$oldIFS
		cat $AUX_FILE | sort -u | uniq
		local total_reglas=`cat $AUX_FILE | wc -l`
	fi

	# Realizar la consulta a iptables
	local consulta_iptables=`grep -i $dato_consulta $VARS_IPV4 | grep -v FICTICIA | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | tr -d [:space:]` #obtener valor
	if is_ipv4_valid $consulta_iptables
	then
		local num_reglas_ipv4_nat=`$IPT_SAVE -t nat | grep "$consulta_iptables" | wc -l`
		if [ $num_reglas_ipv4_nat -gt 0 ]
		then
			message "I: Reglas en IPv4 (nat): $num_reglas_ipv4_nat"
			$IPT_SAVE -c -t nat | grep $consulta_iptables && flag_datos_mostrados=true
		fi
		local num_reglas_ipv4=`$IPT_SAVE | grep "$consulta_iptables" | wc -l`
		if [ $num_reglas_ipv4 -gt 0 ]
		then
			message "I: Reglas en IPv4: $num_reglas_ipv4"
			$IPT_SAVE -c | grep $consulta_iptables && flag_datos_mostrados=true
		fi
	else
		num_reglas_ipv4=0
		num_reglas_ipv4_nat=0
	fi
	# Volvemos a realizar la consulta a iptables, en este caso buscando nateo
	consulta_iptables=`grep $dato_consulta $VARS_IPV6 | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | tr -d [:space:]` #obtener valor
	if is_ipv6_valid $consulta_iptables
	then
		local num_reglas_ipv6=`$IP6T_SAVE | grep "$consulta_iptables" | wc -l`
		if [ $num_reglas_ipv6 -gt 0 ]
		then
			message "I: Reglas en IPv6: $num_reglas_ipv6"
			$IP6T_SAVE -c | grep $consulta_iptables
			flag_datos_mostrados=true
		fi
	else
		num_reglas_ipv6=0
	fi

	total_reglas=$((num_reglas_ipv4_nat + total_reglas))
	total_reglas=$(( total_reglas + num_reglas_ipv4 ))
	total_reglas=$(( total_reglas + num_reglas_ipv6 ))
	message "I: Se han encontrado un total de ${C_BOLD}${total_reglas}${C_NORMAL} reglas coincidentes."


	if [ "$flag_datos_mostrados" != "true" ]
	then
		message "W: No se ha encontrado ninguna informacion relacionada."
	else
		obtener_informacion_retval=0
	fi
	echo "DEBUG: $obtener_informacion_retval" > /dev/null
	IFS=$oldIFS
	return $obtener_informacion_retval
}

# Recibe un fichero
checkear_sintaxis_iptables()
{
	local checkear_sintaxis_iptables_retval=0
	local fichero=$1

	if [[ "$fichero" =~ ^"core"$ ]] || [[ "$fichero" =~ /"core"$ ]] || [[ "$fichero" =~ ^"sets"$ ]] || [[ "$fichero" =~ /"sets"$ ]]
	then
		# no se hace checkeo de sintaxis
		return 0
	fi

	echo "" > $AUX_FILE

	# punto de salida
	if [ ! -r $fichero ]
	then
		message "E: No se ha recibido un nombre de fichero correcto en la funcion checkear_sintaxis_iptables(). Terminando..."
		return 1
	fi

	oldIFS=$IFS
	IFS=$'\n'
	message "I: Checkeando la sintaxis de iptables de [$fichero]:"
	source $VARS_IPV4 && source $VARS_IPSETV4 && { IPT=$IPT_LOCAL ; IPSET=$IPSET_LOCAL ; } \
	|| { message "E: fallo al leer los ficheros de datos IPv4." ; return 1 ; } # punto de salida
	local lineas=`grep -v ^[[:space:]]*# $fichero | grep " -A " | grep -v ^[[:space:]]*$ | wc -l` # para la barra de progreso
	local cont=0 # para la barra de progreso
	for linea in `cat $fichero | nl -b a | egrep -v ^[[:space:]]*[0-9]*[[:space:]]*"#"\|^[[:space:]]*[0-9]*[[:space:]]$ | egrep -v ^[[:space:]]*$\|"IPSET" | grep " -A "`
	do
		((cont++))
		lib_progress_bar -d 2 -m 55 $cont $lineas
		#ipv4
		ejec=`awk -F' ' '{$1=""}1' <<< ${linea/" -A "/" -C "}` # A $linea se le sustituye -A por -C y se quita el numero de linea, luego se evalua
		eval "$ejec 2> /dev/null"
		if [ $? -eq 2 ]
		then
			message "E: La regla de la linea \"`awk -F' ' '{print $1}' <<< $linea`\" parece tener fallos de sintaxis en IPv4." >> $AUX_FILE
			checkear_sintaxis_iptables_retval=1
		fi
	done

	# Si es fichero de nat, no comprobar IPv6
	if grep -i nat <<< $fichero > /dev/null
	then
		echo "DEBUG: No se checkea sintaxis en IPv6 porque es NAT." > /dev/null
	else
		message "I: Checkeando la sintaxis de ip6tables de [$fichero]:"
		local cont=0 #  para la barra de progreso
		source $VARS_IPV6 && source $VARS_IPSETV6 && { IPT=$IP6T_LOCAL ; IPSET=$IPSET_LOCAL ; } \
		|| { message "E: fallo al leer los ficheros de datos IPv6." ; return 1 ; } #punto  de salida
		for linea in `cat $fichero | nl -b a | egrep -v ^[[:space:]]*[0-9]*[[:space:]]*"#"\|^[[:space:]]*[0-9]*[[:space:]]$ | egrep -v ^[[:space:]]*$\|"IPSET" | grep " -A "`
		do
			((cont++))
			lib_progress_bar -d 2 -m 55 $cont $lineas #la variable lineas se reutilza de ipv4
			#ipv6
			ejec=`awk -F' ' '{$1=""}1' <<< ${linea/" -A "/" -C "}` # A $linea se le sustituye -A por -C y se quita el numero de linea, luego se evalua
			eval "$ejec 2> /dev/null"
			if [ $? -eq 2 ]
			then
				message "E: La regla de la linea \"`awk -F' ' '{print $1}' <<< $linea`\" parece tener fallos de sintaxis en IPv6." >> $AUX_FILE
				checkear_sintaxis_iptables_retval=1
			fi
		done
	fi
	grep -v ^[[:space:]]*$ $AUX_FILE
	IFS=$oldIFS
	return $checkear_sintaxis_iptables_retval
}

# Esta funcion parsea un fichero de reglas de iptables/ipset
# y comprueba que su asignacion es correcta
checkear_fichero()
{
	[ ! -z "$flag_no_check" ] && [ $flag_no_check -eq 1 ] && { message "W: No check [$1]." ; return 0 ; }

	local retval=0
	local flag_variables_incorrectas=0
	local flag_iptables_incorrectas=0
	local fichero=$1
	echo "" > $AUX_FILE

	if [ ! -z "$fichero" ] && [ -e $fichero ]
	then
		message "I: Checkeando variables del fichero [$fichero]:"

		# algunos calculos antes del for
		oldIFS=$IFS
		IFS=$' \t\n'
		local lineas=`grep -v ^[[:space:]]*# $fichero | tr [[:space:]] '\n' | fgrep \$ | egrep -v "IPT"$\|"IPSET"$\|^[[:space:]]*$ | sort -u | wc -l`
		local cont=0
		# Se recorren todas variables de $fichero
		for palabra in `grep -v ^[[:space:]]*# $fichero | tr [[:space:]] '\n' | fgrep \$ | egrep -v "IPT"$\|"IPSET"$\|^[[:space:]]*$ | sort -u`
		do
	                ((cont++))
        	        lib_progress_bar -d 2 -m 55 $cont $lineas
			{ [[ "$palabra" =~ "IPT" ]] || [[ "$palabra" =~ "IPSET" ]] || [[ "$palabra" =~ "ip"[6]?"tables" ]] ; } && continue
			local busqueda=`echo $palabra | tr -d '$'`
			{ grep ^$busqueda= $VARS_IPV4 > /dev/null && grep ^$busqueda= $VARS_IPV6 > /dev/null ; } \
				|| { grep ^$busqueda= $VARS_IPSETV4 > /dev/null && grep ^$busqueda= $VARS_IPSETV6 > /dev/null ; } \
				|| { message "W: Revisar variable ${C_BOLD}$busqueda${C_NORMAL}" >> $AUX_FILE; flag_variables_incorrectas=1 ; }
		done
		IFS=$oldIFS

		grep -v ^[[:space:]]*$ $AUX_FILE

		[ $flag_variables_incorrectas -ne 0 ] && return 1 #punto de retorno

		checkear_sintaxis_iptables $fichero || flag_iptables_incorrectas=$?
	else
		message "E: No se ha encontrado el fichero o no tiene permisos de lectura."
		retval=1
	fi
	[ "$flag_variables_incorrectas" -ne 0 ] || [ "$flag_iptables_incorrectas" -ne 0 ] && retval=1
	return $retval
}

salida_controlada_start()
{
	echo ""
	message "W: Abortando el arranque. Dejando reglas permisivas."
	flush_vlan $1
	do_exit 1
}

start()
{
	# Trap de seguridad para la salida
	trap "salida_controlada_start $vlan" SIGHUP SIGINT SIGTERM SIGKILL SIGTSTP SIGQUIT SIGCONT

	local start_retval=0
	local tiempo_inicial=`date +%s`

	# Comprobar que hemos recibido parametro de entrada
	if [ -z "$1" ]
	then
		message "E: Es necesario especificar un nombre vlan/nat/core (el nombre que debe tener el fichero en $CONF_DIR)"
		start_retval=1
	else
		local vlan=$1
		if [ ! -x $CONF_DIR/$vlan ]
		then
			message "E: No se encuentra fichero de vlan/nat/core o no tiene permisos de ejecucion."
			do_exit 1 # PUNTO DE SALIDA
		fi
	fi


	# Se checkea el fichero. PUNTO DE SALIDA
	checkear_fichero $CONF_DIR/$vlan || { message "E: No se inician las reglas porque el checkeo ha fallado."; do_exit 1 ; }

	oldIFS=$IFS
	IFS=$'\n'
	# Iniciando reglas en IPv4
	IPT=$IPT
	local lineas=`grep -v ^[[:space:]]*# $CONF_DIR/$vlan | grep -v ^[[:space:]]*$ | wc -l`
	local cont=0
	message "I: Iniciando reglas en protocolo IPv4:"
	flush_vlan $vlan && source $VARS_IPV4 && source $VARS_IPSETV4 \
	&& for linea in `grep -v ^[[:space:]]*# $CONF_DIR/$vlan | grep -v ^[[:space:]]*$`
	do
		((cont++))
		[ -z "$flag_no_check" ] && lib_progress_bar -d 2 -m 55 $cont $lineas
		eval "$linea 2> /dev/null" \
			|| { echo "" ; message "E: Al iniciar las reglas en IPv4. Regla num (no linea) [$cont]. Dejando reglas permisivas..." ; flush_vlan $vlan ; do_exit 1 ; } #SALIDA
	done || { message "E: Fallo general iniciando reglas en protocolo IPv4." ; flush_vlan $vlan ; do_exit 1 ; } # PUNTO DE SALIDA

	log_vlan $vlan || { message "E: Al agregar las reglas IPv4 de logeo para [$vlan]." ; do_exit 1 ; } # PUNTO DE SALIDA


	if grep -i nat <<< $vlan > /dev/null
	then
		echo "DEBUG: No se insertan reglas en IPv6 porque estamos en nat" > /dev/null
	else
		# Iniciando reglas en IPv6
		IPT=$IP6T
		local cont=0
		message "I: Iniciando reglas en protocolo IPv6:"
		source $VARS_IPV6 && source $VARS_IPSETV6 \
		&& for linea in ` grep -v ^[[:space:]]*# $CONF_DIR/$vlan`
		do
			((cont++))
			[ -z "$flag_no_check" ] && lib_progress_bar -d 2 -m 55 $cont $lineas
			eval "$linea 2> /dev/null" \
				|| { echo "" ; message "E: Al iniciar las reglas en IPv6. Regla num (no linea) [$cont]. Dejando reglas permisivas..." ; flush_vlan $vlan ; do_exit 1 ; } #SALIDA
		done || { message "E: Fallo general iniciando reglas en protocolo IPv6." ; flush_vlan $vlan ; do_exit 1 ; } # PUNTO DE SALIDA

		log_vlan $vlan || { message "E: Al agregar las reglas IPv6 de logeo para [$vlan]." ; do_exit 1 ; } # PUNTO DE SALIDA
	fi
	IFS=$oldIFS
	local tiempo_final=`date +%s`
	message "I: Tiempo total de arranque de ${vlan}: `expr $tiempo_final - $tiempo_inicial` segundos."

	return $start_retval
}

flush_vlan()
{
	local flush_vlan_retval=0
	# Recibe como parametro una vlan o nat
	if [ ! -z "$1" ]
	then
		if grep -i ^"core" <<< $1 > /dev/null
		then
			if [ "$USE_IPTABLES_CLUSTER" == "yes" ]
			then
				# Using iptables-cluster

				# Estamos en el fichero core
				$IPT_CLUSTER -P INPUT ACCEPT 2>/dev/null
				$IPT_CLUSTER -P OUTPUT ACCEPT 2>/dev/null
				$IPT_CLUSTER -P FORWARD ACCEPT 2>/dev/null
				$IPT_CLUSTER -F 2>/dev/null || flush_vlan_retval=1
				$IPT_CLUSTER -F -t nat 2>/dev/null || flush_vlan_retval=1
				$IPT_CLUSTER -X 2>/dev/null || flush_vlan_retval=1
				$IPT_CLUSTER -A FORWARD -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IPT_CLUSTER -A INPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IPT_CLUSTER -A OUTPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1

				$IP6T_CLUSTER -P INPUT ACCEPT 2>/dev/null
				$IP6T_CLUSTER -P OUTPUT ACCEPT 2>/dev/null
				$IP6T_CLUSTER -P FORWARD ACCEPT 2>/dev/null
				$IP6T_CLUSTER -F 2>/dev/null || flush_vlan_retval=1
				$IP6T_CLUSTER -X 2>/dev/null || flush_vlan_retval=1
				$IP6T_CLUSTER -A FORWARD -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IP6T_CLUSTER -A INPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IP6T_CLUSTER -A OUTPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1

				# Eliminamos sets
				$IPSET_CLUSTER flush 2>/dev/null || flush_vlan_retval=1
				$IPSET_CLUSTER x 2>/dev/null || flush_vlan_retval=1
			else
				# Not using iptables-cluster

				# Estamos en el fichero core
				$IPT_LOCAL -P INPUT ACCEPT 2>/dev/null
				$IPT_LOCAL -P OUTPUT ACCEPT 2>/dev/null
				$IPT_LOCAL -P FORWARD ACCEPT 2>/dev/null
				$IPT_LOCAL -F 2>/dev/null || flush_vlan_retval=1
				$IPT_LOCAL -F -t nat 2>/dev/null || flush_vlan_retval=1
				$IPT_LOCAL -X 2>/dev/null || flush_vlan_retval=1
				$IPT_LOCAL -A FORWARD -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IPT_LOCAL -A INPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IPT_LOCAL -A OUTPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1

				$IP6T_LOCAL -P INPUT ACCEPT 2>/dev/null
				$IP6T_LOCAL -P OUTPUT ACCEPT 2>/dev/null
				$IP6T_LOCAL -P FORWARD ACCEPT 2>/dev/null
				$IP6T_LOCAL -F 2>/dev/null || flush_vlan_retval=1
				$IP6T_LOCAL -X 2>/dev/null || flush_vlan_retval=1
				$IP6T_LOCAL -A FORWARD -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IP6T_LOCAL -A INPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				$IP6T_LOCAL -A OUTPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1

				# Eliminamos sets
				$IPSET_LOCAL flush 2>/dev/null || flush_vlan_retval=1
				$IPSET_LOCAL x 2>/dev/null || flush_vlan_retval=1

			fi
		else
			if grep -i nat <<< $1 > /dev/null
			then
				if [ "$USE_IPTABLES_CLUSTER" == "yes" ]
				then
					# Using iptables-cluster

					# Flushing nat rules
					$IPT_CLUSTER -F -t nat 2>/dev/null || flush_vlan_retval=1
				else
					# Not using iptables-cluster

					# Flushing nat rules
					$IPT_LOCAL -F -t nat 2>/dev/null || flush_vlan_retval=1

				fi
			else
				if [ "$USE_IPTABLES_CLUSTER" == "yes" ]
				then
					# No tenemos reglas de nat
					$IPT_CLUSTER -F $1 2>/dev/null || flush_vlan_retval=1
					$IPT_CLUSTER -A $1 -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
					$IP6T_CLUSTER -F $1 2>/dev/null || flush_vlan_retval=1
					$IP6T_CLUSTER -A $1 -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				else
					# No tenemos reglas de nat
					$IPT_LOCAL -F $1 2>/dev/null || flush_vlan_retval=1
					$IPT_LOCAL -A $1 -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
					$IP6T_LOCAL -F $1 2>/dev/null || flush_vlan_retval=1
					$IP6T_LOCAL -A $1 -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2>/dev/null || flush_vlan_retval=1
				fi
			fi
		fi
	else
		flush_vlan_retval=1
	fi
	return $flush_vlan_retval
}

log_vlan()
{
	local log_vlan_retval=0
	local cont=0

	# Recibe como parametro una vlan o nat
	if [ ! -z "$1" ]
	then
		if grep -i core <<< $1 > /dev/null
		then
			# Estamos en el fichero core. Como es posible que sea la primera vez que arranque, esto puede fallar
			# Además, es necesario hacer un for, porque de anteriores ejecuciones fallidas es posible que haya mas reglas
			while $IPT -C FORWARD -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null
			do
				# se evita bucle infinito por un error
				[ $cont -gt 1000 ] && break
				(( cont++ ))

				$IPT -D FORWARD -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null \
					|| message "W: Al eliminar reglas transaccionales durante la operación de core (forward)."
			done

			cont=0
			while $IPT -C INPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null
			do
				# se evita bucle infinito por un error
				[ $cont -gt 1000 ] && break
				(( cont++ ))

				$IPT -D INPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null \
					|| message "W: Al eliminar reglas transaccionales durante la operación de core (input)."
			done
			cont=0
			while $IPT -C OUTPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null
			do
				# se evita bucle infinito por un error
				[ $cont -gt 1000 ] && break
				(( cont++ ))

				$IPT -D OUTPUT -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null \
					|| message "W: Al eliminar reglas transaccionales durante la operación de core (output)."
			done
		else
			if grep -i nat <<< $1 > /dev/null
			then
				# Tenemos reglas de nat
				echo "DEBUG: no haciendo nada de logeo, porque estamos en NAT" > /dev/null
			else
				# No tenemos reglas de nat

				# No se hace log de los sets
				grep -i set <<< $1 > /dev/null || $IPT -A $1 -j LOG --log-level debug --log-prefix "FILTER/${1}:" 2>/dev/null || log_vlan_retval=1
				# El return se agrega siempre
				$IPT -A $1 -j RETURN || log_vlan_retval=1

				# Se borran las reglas transaccionales sobrantes
				cont=0
				while $IPT -C $1 -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null
				do
					# se evita bucle infinito por un error
					[ $cont -gt 1000 ] && break
					(( cont++ ))
					$IPT -D $1 -m comment --comment "regla_transacional_fw-admin" -j ACCEPT 2> /dev/null \
						|| message "W: Al eliminar reglas transaccionales durante la operación de $1."
				done
			fi
		fi
	else
		log_vlan_retval=1
	fi
	return $log_vlan_retval
}


stop()
{
	local stop_retval=0
        # Comprobar que hemos recibido parametro de entrada
        if [ -z "$1" ]
        then
                message "E: Es necesario especificar un nombre de vlan/nat/core (el nombre que debe tener el fichero en $CONF_DIR)"
                stop_retval=1
        else
                local vlan=$1
                if [ ! -x $CONF_DIR/$vlan ]
                then
                        message "E: No se encuentra fichero de vlan/nat/core o no tiene permisos de ejecucion."
                        stop_retval=1
                fi
        fi

	if [ $stop_retval -eq 0 ]
	then
		flush_vlan $vlan || message "W: Fallo al flushear las reglas de la vlan/nat/core"
	fi

	return $stop_retval
}

# Se llama sin parametros
# checkea y recarga los datos de conjuntos
ipset_reload()
{
	local ipset_reload_retval=0
	local tiempo_inicio="`date +%s`"

	# Checkear el fichero de IPSET
	checkear_fichero $IPSET_CONF || return $?

	message "I: Recargando ahora informacion de sets en IPv4."
	source $VARS_IPV4 && source $VARS_IPSETV4 \
		|| { message "E: No se cargan los ficheros de datos en IPv4 de IPSET." ; ipset_reload_retval=1 ; }
	if [ $ipset_reload_retval -eq 0 ]
	then
		local lineas=`grep -v ^[[:space:]]*# $IPSET_CONF | grep -v ^[[:space:]]*$ | wc -l` #total de lineas ejecutables
		local cont=0
		oldIFS=$IFS
		IFS=$'\n'
		for linea in `grep -v ^[[:space:]]*# $IPSET_CONF | grep -v ^[[:space:]]*$` #recorriendo fichero linea a linea
		do
			((cont++))
			[ -z "$flag_no_check" ] && lib_progress_bar -d 2 -m 55 $cont $lineas
			eval "${linea} 2>/dev/null" || { message "E: Fallo al recargar sets en IPv4. Regla num (no linea) [$cont]." ; do_exit 1 ; }
		done
		IFS=$oldIFS
	fi
	message "I: Recargando ahora informacion de sets en IPv6."
	source $VARS_IPV6 && source $VARS_IPSETV6 \
		|| { message "E: No se cargan los ficheros de datos en IPv6 de IPSET." ; ipset_reload_retval=1 ; }
	if [ $ipset_reload_retval -eq 0 ]
	then
		local lineas=`grep -v ^[[:space:]]*# $IPSET_CONF | grep -v ^[[:space:]]*$ | wc -l` #total de lineas ejecutables
		local cont=0
		oldIFS=$IFS
		IFS=$'\n'
		for linea in `grep -v ^[[:space:]]*# $IPSET_CONF | grep -v ^[[:space:]]*$` #recorriendo fichero linea a linea
		do
			((cont++))
			[ -z "$flag_no_check" ] && lib_progress_bar -d 2 -m 55 $cont $lineas
			eval "${linea} 2>/dev/null" || { message "E: Fallo al recargar sets en IPv6. Regla num (no linea) [$cont]." ; do_exit 1 ; }
		done
		IFS=$oldIFS
	fi

        local tiempo_final="`date +%s`"
        message "I: Tiempo total de recarga de sets: `expr $tiempo_final - $tiempo_inicio` segundos."

	return $ipset_reload_retval
}

# Funcion para la barra de progreso
# http://www.brianhare.com/wordpress/2011/03/02/bash-progress-bar/
	#lib_progress_bar $i 100
	#lib_progress_bar -d 2 -m 55 $i 1241
lib_progress_bar() {

	local current=0
	local max=100
	local completed_char="#"
	local uncompleted_char="."
	local decimal=1
	local prefix=" ["
	local suffix="]"
	local percent_sign="%"
	local max_width=$(tput cols)
	local complete remain subtraction width atleast percent chars
	local padding=3

	local OPTIND

	while getopts c:u:d:p:s:%:m:hV flag; do
		case "$flag" in
			c) completed_char="$OPTARG";;
			u) uncompleted_char="$OPTARG";;
			d) decimal="$OPTARG";;
			p) prefix="$OPTARG";;
			s) suffix="$OPTARG";;
			%) percent_sign="$OPTARG";;
			m) max_width="$OPTARG";;

			(h) lib_help;;
			(V) echo "$lib_script_name: version $Revision$ ($Date$)"; exit 0;;
			(*) lib_usage;;
		esac
	done
	shift $((OPTIND-1))

	current=${1:-$current}
	max=${2:-$max}

	if (( decimal > 0 )); then
		(( padding = padding + decimal + 1 ))
	fi

	let subtraction=${#completed_char}+${#prefix}+${#suffix}+padding+${#percent_sign}
	let width=max_width-subtraction

	if (( width < 5 )); then
		(( atleast = 5 + subtraction ))
		echo >&2 "the max_width of ($max_width) is too small, must be atleast $atleast"
		return 1
	fi

    if (( current > max ));then
        echo >&2 "current value must be smaller than max. value"
        return 1
    fi

    percent=$(awk -v "f=%${padding}.${decimal}f" -v "c=$current" -v "m=$max" 'BEGIN{printf('f', c / m * 100)}')

    (( chars = current * width / max))

    # sprintf n zeros into the var named as the arg to -v
    printf -v complete '%0*.*d' '' "$chars" ''
    printf -v remain '%0*.*d' '' "$((width - chars))" ''

    # replace the zeros with the desired char
    complete=${complete//0/"$completed_char"}
    remain=${remain//0/"$uncompleted_char"}

    printf '%s%s%s%s %s%s\r' "$prefix" "$complete" "$remain" "$suffix" "$percent" "$percent_sign"

	if (( current >= max )); then
		echo ""
	fi
}
