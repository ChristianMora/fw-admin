#!/bin/bash

# Arturo Borrero <aborrero@cica.es>
#
# Copyright (c) 2012 Arturo Borrero
# This file is released under the GPLv3 license.
#
# Can obtain a complete copy of the license at: http://www.gnu.org/licenses/gpl-3.0.html
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

################################################################
################################################################
# Variables
PID=$$
THIS="`uname -n`"

IPSET="/usr/sbin/ipset"
IPT="/sbin/iptables"
IP6T="/sbin/ip6tables"
IPSET_LOCAL="/usr/sbin/ipset"
IPT_LOCAL="/sbin/iptables"
IP6T_LOCAL="/sbin/ip6tables"
IPT_SAVE="/sbin/iptables-save"
IPT_RESTORE="/sbin/iptables-restore"
IP6T_SAVE="/sbin/ip6tables-save"
IP6T_RESTORE="/sbin/ip6tables-restore"
CONNTRACKD="/usr/sbin/conntrackd"
CONNTRACK="/usr/sbin/conntrack"
DIG="/usr/bin/dig"

AUX_FILE="`mktemp`"

LOGGER_BIN="/usr/bin/logger"
ARGS_LOGGER="-t fw-admin[$PID] --"

################################################################
################################################################
# Control functions

# void message(string message)
# Show a message to stdout and/or stderr. Maybe also to logger
message()
{
	# $1 is the raw message

	local message=${*}

	# colour if configured
	if [ "$USE_COLORS" == "yes" ]
	then
		message=${message/"E: "/"${C_RED}E:${C_NORMAL} "}
		message=${message/"W: "/"${C_YELLOW}W:${C_NORMAL} "}
		message=${message/"I: "/"${C_GREENBOLD}I:${C_NORMAL} "}
	fi

	# what to do with the message
	if [[ $1 =~ ^"E:" ]]
	then
		echo -e "$message" >&2
		[ "$LOG_ERROR_MESSAGES" == "yes" ] && $LOGGER_BIN $ARGS_LOGGER $1
		return 0
	fi
	if [[ $1 =~ ^"W:" ]]
	then
		echo -e "$message" >&2
		[ "$LOG_WARN_MESSAGES" == "yes" ] && $LOGGER_BIN $ARGS_LOGGER $1
		return 0
	fi

	# If not returned yet, the message wasn't E: or W:, so print it to stdout
	echo -e "$message"

	return 0
}

# void do_exit(int exit_code)
# Exit the program, flushing PID_FILE and AUX_FILE
do_exit()
{
	if [ -r "$PID_FILE" ]
	then
		if [ "`cat $PID_FILE`" == "${$}" ] 2> /dev/null # Borramos el lock file solo si es nuestro
		then
			rm -f $PID_FILE 2> /dev/null
		fi
	fi
	if [ -e "$AUX_FILE" ]
	then
		rm -f $AUX_FILE 2> /dev/null
	fi
	exit $1
}

# boolean validate_execution()
# Check if there are other instance in critical mode
validate_execution()
{
	# If PID_FILE doesn't exist
	# the execution is our's, so put pid to PID_FILE
	if [ ! -r $PID_FILE ]
	then
		echo "${$}" > $PID_FILE 2> /dev/null
	fi

	local pid=`cat $PID_FILE`
	if [ "$pid" != "${$}" ] 2> /dev/null
	then
		message "E: PID_FILE already exist with pid ${pid} $PID_FILE"
		do_exit 1
	fi
	return 0
}


# boolean check_root()
# Check if this is a root execution.
check_root()
{
	local check_root_retval=0
	if [ `id -u` -ne 0 ]
	then
		check_root_retval=1
	fi
	return $check_root_retval
}

# boolean check_files()
# Check for all required files and bins.
check_files()
{
	local check_files_retval=0
	[ -x $IPT_SAVE ] || { message "E: Binary not found [$IPT_SAVE]" ; check_files_retval=1 ; }
	[ -x $IP6T_SAVE ] || { message "E: Binary not found [$IP6T_SAVE]" ; check_files_retval=1 ; }
	[ -x $IPT_RESTORE ] || { message "E: Binary not found [$IPT_RESTORE]" ; check_files_retval=1 ; }
	[ -x $IP6T_RESTORE ] || { message "E: Binary not found [$IP6T_RESTORE]" ; check_files_retval=1 ; }
	[ -w $AUX_FILE ] || { message "E: Unable to create aux file [$AUX_FILE]" ; check_files_retval=1 ; }
	[ -d $CONF_DIR ] || { message "E: Dir not found [$CONF_DIR]" ; check_files_retval=1 ; }
	[ -x $IPSET_CONF ] || { message "E: File not found [$IPSET_CONF]" ; check_files_retval=1 ; }
	[ -d $DATA_DIR ] || { message "E: Dir not found [$DATA_DIR]" ; check_files_retval=1 ; }
	[ -w $VARS_IPV6 ] || { message "E: File not found [$VARS_IPV6]" ; check_files_retval=1 ; }
	[ -w $VARS_IPV4 ] || { message "E: File not found [$VARS_IPV4]" ; check_files_retval=1 ; }
	[ -w $VARS_IPSETV6 ] || { message "E: File not found [$VARS_IPSETV6]" ; check_files_retval=1 ; }
	[ -w $VARS_IPSETV4 ] || { message "E: File not found [$VARS_IPSETV4]" ; check_files_retval=1 ; }
	[ -x $IPT ] || { message "E: Binary not found [$IPT]." ; check_files_retval=1 ; }
	[ -x $IP6T ] || { message "E: Binary not found [$IP6T]." ; check_files_retval=1 ; }
	[ -x $IPSET ] || { message "E: Binary not found [$IPSET]." ; check_files_retval=1 ; }
	[ -x $DIG ] || { message "E: Binary not found [$DIG]" ; check_files_retval=1 ; }

	return $check_files_retval
}

# string get_absolute_path(string filename)
# Obtain the absolute pathname to a given filename, first looking into $CONF_DIR
get_absolute_path()
{
	local filename=$1
	local get_absolute_path_retval=1

	# Here we have 2 options.
	#	1. The argument is a file in $CONF_DIR, so we return the absolute pathname as we know it.
	#	2. The argument already is an absolute pathname, so return it.

	# Check just for read permission. Don't need execution.

	if [ -r "$CONF_DIR/$filename" ]
	then
		get_absolute_path_retval=0
		echo "$CONF_DIR/$filename" # the string return
	else
		if [ -r "$filename" ]
		then
			get_absolute_path_retval=0
			echo "$filename" # the string return
		fi
	fi
	return $get_absolute_path_retval
}

# string libprogressbar(int i, int max)
# Forked from http://www.brianhare.com/wordpress/2011/03/02/bash-progress-bar/
# Use this for easily test
# $ max=1000
# $ for i in `seq 1 $max`; do libprogressbar $i $max ; done
libprogressbar()
{

	# This needs strong optimization.

        local current=0
        local max=100
        local decimal=1
        local max_width=50
        local subtraction width atleast percent chars
        local padding=5

	current=${1:-$current}
	max=${2:-$max}

	# Delete the bar now
	if [ $max -eq $current ]
	then
		printf '%s\r' "                                                             "
		return 0
	fi

        let subtraction=${#completed_char}+${#prefix}+${#suffix}+padding+${#percent_sign}
        let width=max_width-subtraction

	if (( current > max ))
	then
		echo >&2 "libprogressbar: current value must be smaller than max. value"
		return 1
	fi

	percent=$(awk -v "f=%5.1f" -v "c=$current" -v "m=$max" 'BEGIN{printf('f', c / m * 100)}')
	(( chars = current * width / max))

	# sprintf n zeros into the var named as the arg to -v
	printf -v complete '%0*.*d' '' "$chars" ''
	printf -v remain '%0*.*d' '' "$((width - chars))" ''

	# replace the zeros with the desired char
	#complete=${complete//0/"#"} #completed char
	#remain=${remain//0/"."} #uncompleted char

	printf ' %s%s%s%s %s%s\r' "[" "${complete//0/-}" "${remain//0/ }" "]" "$percent" "%"

	if (( current >= max ))
	then
		echo ""
	fi
	return 0
}


################################################################
################################################################
# Datafile functions

# boolean is_ipv4_valid(string ipv4)
# Check if an ipv4 is a valid ipv4
is_ipv4_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		egrep '^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$' <<< $1 > /dev/null
		if [ $? -eq 0 ]
		then
			retval=0
		fi
	fi
	return $retval
}

# boolean is_ipv6_valid(string ipv6)
# Check if an ipv6 is a valid ipv6
is_ipv6_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		egrep -E '^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:)))(%.+)?\s*$' <<< $1 > /dev/null
		if [ $? -eq 0 ]
		then
			retval=0
		fi
	fi
	return $retval
}

# boolean is_fqdn_valid(string fqdn)
# Check if an fqdn is a valid fqdn
is_fqdn_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		# resolve it to know if it's valid
		local resolution=`$DIG +short $1 2>/dev/null | wc -l 2>/dev/null`
		if [ ! -z "$resolution" ] && [[ $resolution =~ ^[0-9]+$ ]] && [ $resolution -ne 0 ]
		then
			retval=0
		fi
	fi
	return $retval
}

# boolean is_ip_fqdn_valid(string ip_or_fqdn)
# Check if an address is valid (ip or fqdn)
is_ip_fqdn_valid()
{
	local retval=1
	if [ ! -z $1 ]
	then
		is_ipv6_valid $1 && retval=0
		is_ipv4_valid $1 && retval=0
		is_fqdn_valid $1 && retval=0
	fi
	return $retval
}

# boolean is_domain_fqdn(string fqdn)
# Funcion que valora si un fqdn es del dominio cica.es
is_domain_fqdn()
{
	local retval=1
	grep "$DOMAIN"$ <<< $1 > /dev/null
	if [ $? -eq 0 ]
	then
		retval=0
	fi
	return $retval
}



# boolean reload_variable_values()
# Esta funcion recorre todas las variables del sistema, reajustando su valor.
reload_variable_values()
{
	local reload_variable_values_retval=0
	echo -n "" > $AUX_FILE

	message "I: Variables containing the tag \"##ignore##\" are ignored."

	local lista_variables=`{ cat $VARS_IPV4 ; cat $VARS_IPV6 ; } | egrep -v "##ignorar##"\|"##ignore##"\|"@"\|^[[:space:]]*# \
		| awk -F'#' '{print $2}' | sort -u | uniq | grep -v ^[[:space:]]*$`

	# Evaluating if calcules regarding progress bar are neccesary
	if [ "$USE_PROGRESS_BAR" == "yes" ]
	then
		local total=`wc -w <<< $lista_variables`
		local cont=0
	fi

	oldIFS=$IFS ; IFS=$' \t\n' #control over IFS
	for variable in $lista_variables
	do
		# Evaluating if calcules regarding progress bar are neccesary
		if [ "$USE_PROGRESS_BAR" == "yes" ]
		then
			((cont++))
			libprogressbar $cont $total
		fi
		# Solo se mostraran luego los mensajes de error
		add_ip_variable $variable >> $AUX_FILE 2>&1 || reload_variable_values_retval=1
	done
	IFS=$oldIFS

	local checklist=`grep "E:" $AUX_FILE`
	if [ ! -z "$checklist" ]
	then
		echo -e "$checklist"
	fi
	return $reload_variable_values_retval
}

# string get_variable_name(string data)
# Used to know what variable name correspond to the given data
get_variable_name()
{
	# Check for empty argument
	if [ -z "$1" ]
	then
		message "E: empty argument in function get_variable_name()"
		do_exit 1
	fi

	# Check if the data is IPv4
	if is_ipv4_valid $1
	then
		# return
		echo v$1 | tr '.' '_'
		return 0
	fi

	# Check if the data is IPv6
	if is_ipv6_valid $1
	then
		# return
		echo v$1 | tr ':' '_'
		return 0
	fi

	# Check if the data is FQDN
	if is_fqdn_valid $1
	then
		local name="$1"
		# if is from $DOMAIN, delete $DOMAIN
		is_domain_fqdn $1 && name=`echo $1 | awk -F".$DOMAIN" '{print $1}'`
		# if starts with a number, starts now with 'v'
		[[ $name =~ ^[0-9] ]] && name="v${name}"
		# and then return
		echo $name | tr [:lower:] [:upper:] | tr '.' '_' | tr '-' '_'
		return 0
	fi

	return 1
}

# ip get_ip_from_fqdn(string tipo_ip, string fqdn, int recursivityLevel)
# recursive function. Used to know the final IP asociated with an FQDN.
get_ip_from_fqdn()
{
        local tipo_ip=$1
        local fqdn=$2
	local recursivityLevel=$3

	[ -z "$tipo_ip" ] && { message "E: Function get_ip_from_fqdn() called with empty parameter (type)" ; do_exit 1 ; }
	[ -z "$fqdn" ] && { message "E: Function get_ip_from_fqdn() called with empty parameter (fqdn)" ; do_exit 1 ; }
	[ -z "$recursivityLevel" ] && recursivityLevel=0
	[ "$recursivityLevel" -gt 100 ] && { message "E: Max recursion level reached in function get_ip_from_fqdn()" ; do_exit 1 ; }
	((recursivityLevel++))

        local resolution=`$DIG +short $fqdn $tipo_ip`
        if is_ipv6_valid $resolution
        then
                echo "$resolution" # return point
        else
		if is_ipv4_valid $resolution
		then
			echo "$resolution" # return point
		else
			oldIFS=$IFS
			IFS=$' \t\n'
	                for linea in $resolution
	                do
	                        local resolution2="$resolution2 $(get_ip_from_fqdn $tipo_ip $linea $recursivityLevel)"
	                done
			IFS=$oldIFS
	                local resolution3=`echo "$resolution2" | tr [[:space:]] '\n' | grep -v ^[[:space:]]*$ | sort -u | uniq`
	                echo "$resolution3" # return point
		fi
        fi
	return 0
}


# boolean add_ip_variable(string data)
# Used to add a variale to IP datafiles
add_ip_variable()
{
	# trap de cancelacion
	trap " echo "" && message \"W: Interrupt...\" && do_exit 1 " SIGHUP SIGINT SIGTERM SIGKILL SIGTSTP SIGQUIT SIGCONT

	local add_ip_variable_retval=0
	local data_to_add=$1

	if [ -z "$data_to_add" ]
	then
		# No input data, use prompt
		read -p "-> Define IPv4, IPv6 or FQDN: " data_to_add
	fi

	#
	# Validations
	#
	{ is_ipv4_valid $data_to_add || is_ipv6_valid $data_to_add || is_fqdn_valid $data_to_add ; } \
		|| { message "E: Data is not a valid IP or FQDN: \"$data_to_add\"" ; add_ip_variable_retval=1 ; }


	# Continue only if parameter was validated
	if [ $add_ip_variable_retval -eq 0 ]
	then

		#
		# Calculate the name of the variable
		#
		variable_name=$( get_variable_name $data_to_add )
		[ $? -ne 0 ] && { message "E: Unable to determine the variable name" ; do_exit 1 ; }

		echo "DEBUG: $variable_name=$data_to_add #$data_to_add" > /dev/null

		if grep ^"${variable_name}=" $VARS_IPV4 > /dev/null 2> /dev/null && grep ^"${variable_name}=" $VARS_IPV6 > /dev/null 2> /dev/null
		then
			# The variable is already stored.
			message "W: Refreshing variable data: ${variable_name}"
		else
			message "I: The variable name is: ${variable_name}"
		fi

		#
		# Write to datafiles
		#
		store_in_ipdatafile "ipv4" "$variable_name" "$data_to_add" \
			|| { message "E: Unable to store $data_to_add in file ${VARS_IPV4}" ; do_exit 1 ; }
		store_in_ipdatafile "ipv6" "$variable_name" "$data_to_add" \
			|| { message "E: Unable to store $data_to_add in file ${VARS_IPV6}" ; do_exit 1 ; }

		#
		# Check if all went fine
		#
		grep ^"${variable_name}=" $VARS_IPV4 > /dev/null 2> /dev/null || add_ip_variable_retval=1
		grep ^"${variable_name}=" $VARS_IPV6 > /dev/null 2> /dev/null || add_ip_variable_retval=1

		[ $add_ip_variable_retval -ne 0 ] &&  message "W: There is an error when storing in datafiles the variable ${variable_name}"
	fi
	return $add_ip_variable_retval

}

# boolean add_set_variable(string data_to_add)
# To add a set variable to datafiles
add_set_variable()
{
	local agregar_set_retval=0
	local data_to_add=$1

	if [ -z "$data_to_add" ]
	then
		# No input data, use a prompt
		read -p "-> Define set name: " data_to_add
	fi

	# Validation
	data_to_add=`tr [:lower:] [:upper:] <<< $data_to_add`
	# Must not exist
	( grep -i "${data_to_add}_ipv4" $VARS_IPSETV4 > /dev/null && grep -i "${data_to_add}_ipv6" $VARS_IPSETV6 > /dev/null ) \
		&& { message "W: The variable already exist." ; agregar_set_retval=1 ; }

	# Continue only if parameter was validated.
	if [ $agregar_set_retval -eq 0 ]
	then
		#
		# Write to datafiles
		#
		echo "$data_to_add=`tr [:upper:] [:lower:] <<< $data_to_add`_ipv4" >> $VARS_IPSETV4 \
				|| { message "E: Unable to write $VARS_IPSETV4" ; agregar_set_retval=1 ; }
		echo "$data_to_add=`tr [:upper:] [:lower:] <<< $data_to_add`_ipv6" >> $VARS_IPSETV6 \
				|| { message "E: Unable to write $VARS_IPSETV6" ; agregar_set_retval=1 ; }

		# Not very usefull
		#echo "The stored data: "
		#grep ^"${data_to_add}=" $VARS_IPSETV4 2>/dev/null
		#grep ^"${data_to_add}=" $VARS_IPSETV6 2>/dev/null
	fi

	return $agregar_set_retval
}


# boolean store_in_ipdatafile(string protocol, string variable_name, string data_to_add)
# Store in the datafile a variable.
# protocol: {ipv4|ipv6}
store_in_ipdatafile()
{
	local store_in_ipdatafile_retval=0
	local protocol=$1
	local variable_name=$2
	local data_to_add=$3

	if [ -z "$variable_name" ]
	then
		store_in_ipdatafile_retval=1
	fi
	if [ -z "$data_to_add" ]
	then
		store_in_ipdatafile_retval=1
	fi

	case "$protocol" in
		"ipv4")
			local working_file=$VARS_IPV4
			;;
		"ipv6")
			local working_file=$VARS_IPV6
			;;
		*)
			store_in_ipdatafile_retval=1
			;;
	esac

	# EXIT POINT
	if [ $store_in_ipdatafile_retval -ne 0 ]
	then
		message "E: Bad call to function store_in_ipdatafile() Invalid input arguments"
		do_exit 1
	fi

	# Cleaning previous data
	if grep ^"${variable_name}=" $working_file > /dev/null
	then
		local data=`grep -v ^"${variable_name}=" $working_file | grep -v ^[[:space:]]*$`
		echo "$data" > $working_file
		if [ $? -ne 0 ]
		then
			message "E: When cleaning the previous data. Dataloss is expected"
			do_exit 1
		fi
	fi

	[ $store_in_ipdatafile_retval -ne 0 ] && return $store_in_ipdatafile_retval # Return point


	# How to store data if we are working with a FQDN
	if is_fqdn_valid $data_to_add
	then
		case "$protocol" in
			"ipv4" )
				# get the A
				local resolution="$(get_ip_from_fqdn A $data_to_add 0)"
				;;
			"ipv6" )
				# get the AAAA
				local resolution="$(get_ip_from_fqdn AAAA $data_to_add 0)"
				;;
		esac

		if [ -z "$resolution" ]
		then
			# No resolution for this FQDN
			echo "${variable_name}=\$VOID #$data_to_add" >> $working_file
			if [ $? -ne 0 ]
			then
				message "E: Unable to store data [${data_to_add}] (void) to [$working_file]. Possible dataloss"
				do_exit 1
			fi
		else
			# There is resolution for this FQDN
			if [ `echo "$resolution" | wc -l` -gt 1 ]
			then
				# Complex resolution.
				echo "${variable_name}=${data_to_add} #$data_to_add" >> $working_file
				if [ $? -ne 0 ]
				then
					message "E: Unable to store data [${data_to_add}] (complex) to [$working_file]. Possible dataloss."
					do_exit 1
				fi
			else
				# Standar resolution
				echo "${variable_name}=$resolution #$data_to_add" >> $working_file
				if [ $? -ne 0 ]
				then
					message "E: Unable to store data [${data_to_add}] (standar) to [$working_file]. Possible dataloss."
					do_exit 1
				fi
			fi
		fi
	else # Plain IP (v4 or v6)
		# How to store data if we are working with an IPv6
		if is_ipv6_valid $data_to_add
		then
			case "$protocol" in
				"ipv4" )
					echo "${variable_name}=\$VOID #$data_to_add" >> $working_file
					if [ $? -ne 0 ]
					then
						message "E: Unable to store data [${data_to_add}] (void) to [$working_file]. Possible dataloss."
						do_exit 1
					fi
					;;
				"ipv6" )
					echo "${variable_name}=${data_to_add} #$data_to_add" >> $working_file
					if [ $? -ne 0 ]
					then
						message "E: Unable to store data [${data_to_add}] (void) to [$working_file]. Possible dataloss."
						do_exit 1
					fi
					;;
			esac
		else
			# How to store data if we are working with an IPv4
			if is_ipv4_valid $data_to_add
			then
				case "$protocol" in
					"ipv4" )
						echo "${variable_name}=${data_to_add} #$data_to_add" >> $working_file
						if [ $? -ne 0 ]
						then
							message "E: Unable to store data [${data_to_add}] (standar) to [$working_file]. Possible dataloss."
							do_exit 1
						fi
						;;
					"ipv6" )
						echo "${variable_name}=\$VOID #$data_to_add" >> $working_file
						if [ $? -ne 0 ]
						then
							message "E: Unable to store data [${data_to_add}] (standar) to [$working_file]. Possible dataloss."
							do_exit 1
						fi
						;;
				esac
			else
				message "E: Bad call to function store_in_ipdatafile(). Invalid data."
				store_in_ipdatafile_retval=1
			fi
		fi
	fi
	return $store_in_ipdatafile_retval
}

# boolean delete_data(string data_to_delete)
# Validate the given data and delete it from datafiles
delete_data()
{
	local delete_data_retval=0
	local data_to_delete=$1
	local flag_something_deleted=0
	echo -n "" > $AUX_FILE

	# We don't know if data_to_delete is a variable of IPSET or IP/FQDN
	# Try now to resolve to a VAR name
	get_input_abstracted_of_type $data_to_delete $AUX_FILE

	# AUX_FILE now contains a repeated and unordered list of matches (or not)
	if [ $( cat $AUX_FILE | wc -l) -gt 0 ]
	then
		# Yes, is filled with lines like this:
		#/path/to/datafile: VAR=data #comment

		# Iterate over the list of vars
		for var in $( awk -F'=' '{print $1}' $AUX_FILE | awk -F' ' '{print $2}' | sort | uniq )
		do
			read -p "-> Delete the IP/FQDN variable \"${var}\"? [y/N]: "
			if [ "$REPLY" == "y" ] # REPLY is a special variable by read
			then
				delete_from_datafile $var $VARS_IPV4 \
					|| { message "W: Something went wrong when deleting ${var} from $VARS_IPV4" ; delete_data_retval=1 ; break ; }
				delete_from_datafile $var $VARS_IPV6 \
					|| { message "W: Something went wrong when deleting ${var} from $VARS_IPV6" ; delete_data_retval=1 ; break ; }
				message "W: Deleted IP/FQDN variable \"${var}\""
				flag_something_deleted=1
			fi
		done
	fi

	# IP/FQDN variables were not found. Maybe we are triying to delete a IPSET variable?
	if egrep ^[[:space:]]*${data_to_delete}= $VARS_IPSETV4 > /dev/null &&  egrep ^[[:space:]]*${data_to_delete}= $VARS_IPSETV6 > /dev/null
	then
		# We found data to delete in IPSET datafiles!!
		read -p "-> Delete the ipset variable \"${data_to_delete}\"? [y/N]: "
		if [ "$REPLY" == "y" ] # REPLY is a special variable by read
		then
			delete_from_datafile $data_to_delete $VARS_IPSETV4 \
				|| { message "W: Something went wrong when deleting ${data_to_delete} from $VARS_IPSETV4" ; delete_data_retval=1 ; }
			delete_from_datafile $data_to_delete $VARS_IPSETV6 \
				|| { message "W: Something went wrong when deleting ${data_to_delete} from $VARS_IPSETV6" ; delete_data_retval=1 ; }
			message "W: Deleted ipset variable \"${data_to_delete}\""
			flag_something_deleted=1
		fi
	fi

	if [ $flag_something_deleted -eq 0 ]
	then
		# Warning, nothing to do
		message "W: No data found to delete"
		delete_data_retval=1
	else
		# Force a check-datafiles
		echo ""
		message "I: Automatically checking datafiles because of the delete"
		check_datafiles || delete_data_retval=$?
	fi

	return $delete_data_retval
}

# boolean delete_from_datafile(string variable_name, string datafile)
# Delete the variable_name from the given datafile
delete_from_datafile()
{
	local delete_from_dafatile_retval=1

	local variable_name=$1
	local datafile=$2
	local hash=""

	cp $datafile ${datafile}~ || { message "E: Unable to copy the datafile $datafile to operate" ; do_exit 1 ; }
	local tmpfile=$( grep -v ^${variable_name}= ${datafile}~ 2>/dev/null )

	hash=$( sha512sum <<< "$tmpfile" )
	echo "$tmpfile" > ${datafile}~

	if [ "$hash" == "$( sha512sum < ${datafile}~ )" ]
	then
		mv ${datafile}~ $datafile 2>/dev/null || { message "E: Unable to copy back $datafile" ; do_exit 1 ; }
		delete_from_datafile_retval=0
	else
		message "E: Unable to operate. Bad integrity $datafile"
		do_exit 1
	fi

	return $delete_from_datafile_retval
}


################################################################
################################################################
# Utilities functions

# boolean stats()
# Print stats to stdout.
stats()
{
	local retval=0

	# Info iptables
	echo -e "### About iptables  \tIPv4\tIPv6\ttotal"
	local num_of_ipv4_rules=`$IPT_SAVE 2>/dev/null | grep ^- 2>/dev/null | wc -l`
	local num_of_ipv6_rules=`$IP6T_SAVE 2>/dev/null | grep ^- 2>/dev/null | wc -l`
	local num_of_ipv4_rules_nomatch=`$IPT_SAVE -c 2>/dev/null | grep ^"\[0:0\]" | wc -l`
	local num_of_ipv6_rules_nomatch=`$IP6T_SAVE -c 2>/dev/null | grep ^"\[0:0\]" | wc -l`

	[[ $num_of_ipv4_rules =~ ^[0-9]+$ ]] || num_of_ipv4_rules=0
	[[ $num_of_ipv6_rules =~ ^[0-9]+$ ]] || num_of_ipv6_rules=0
	[[ $num_of_ipv4_rules_nomatch =~ ^[0-9]+$ ]] || num_of_ipv4_rules_nomatch=0
	[[ $num_of_ipv6_rules_nomatch =~ ^[0-9]+$ ]] || num_of_ipv6_rules_nomatch=0


	local num_of_ipv4_rules_match=$(( num_of_ipv4_rules - num_of_ipv4_rules_nomatch ))
	local num_of_ipv6_rules_match=$(( num_of_ipv6_rules - num_of_ipv6_rules_nomatch ))
	[[ $num_of_ipv4_rules_match =~ ^[0-9]+$ ]] || num_of_ipv4_rules_match=0
	[[ $num_of_ipv6_rules_match =~ ^[0-9]+$ ]] || num_of_ipv6_rules_match=0

	echo -e " Rules with match: \t $(( num_of_ipv4_rules_match )) \t $(( num_of_ipv6_rules_match )) \t $(( num_of_ipv4_rules_match + num_of_ipv6_rules_match ))"
	echo -e " Rules not in use: \t $num_of_ipv4_rules_nomatch \t $num_of_ipv6_rules_nomatch \t $(( num_of_ipv4_rules_nomatch + num_of_ipv6_rules_nomatch ))"
	echo -e " Amount of rules: \t $num_of_ipv4_rules \t $num_of_ipv6_rules \t $(( num_of_ipv4_rules + num_of_ipv6_rules ))"
	echo " Use and default policy IPv4:"
	$IPT -n -L -v 2>/dev/null | grep policy | while read linea
	do
		echo -e "\t$linea"
	done
	echo " Use and default policy IPv6:"
	$IP6T -n -L -v 2>/dev/null | grep policy | while read linea
	do
		echo -e "\t$linea"
	done
	echo " Hash of the ruleset: `( { $IPT_SAVE 2>/dev/null ; $IP6T_SAVE 2>/dev/null; } | grep ^"-" | md5sum | awk -F' ' '{print $1}' ) || echo error! `"

	echo ""

	# Info ipset
	echo -e "### About ipset"
	local num_of_sets=`$IPSET list -n 2>/dev/null | wc -l`

	[[ $num_of_sets =~ ^[0-9]+$ ]] || num_of_sets=0

	local num_of_sets_nomatch=`$IPSET list 2>/dev/null | grep "References: 0" | wc -l`

	[[ $num_of_sets_nomatch =~ ^[0-9]+$ ]] || num_of_sets_nomatch=0

	echo -e " Sets referenced by rules: \t $(( num_of_sets - num_of_sets_nomatch ))"
	echo -e " Sets not referenced by rules: \t $num_of_sets_nomatch"
	echo -e " Sets in kernel: \t\t $num_of_sets"

	echo ""


	# Info variables
	echo -e "### Other data\t\t\tIPv4\tIPv6"
	local vars_ipv4=`grep \= $VARS_IPV4 2>/dev/null | wc -l`
	local vars_ipv6=`grep \= $VARS_IPV6 2>/dev/null | wc -l`
	local vars_ipset_ipv4=`grep \= $VARS_IPSETV4 2>/dev/null | wc -l`
	local vars_ipset_ipv6=`grep \= $VARS_IPSETV6 2>/dev/null | wc -l`
	echo -e " Declared iptables variables:\t $vars_ipv4 \t $vars_ipv6"
	echo -e " Declared ipset variables:\t $vars_ipset_ipv4 \t $vars_ipset_ipv6"
	echo ""

	[[ $MINIMAL_AMOUNT_OF_RULES =~ ^[0-9]+$ ]] || MINIMAL_AMOUNT_OF_RULES=40
	if [ $num_of_ipv4_rules -gt $MINIMAL_AMOUNT_OF_RULES ] || [ $num_of_ipv6_rules -gt $MINIMAL_AMOUNT_OF_RULES ]
	then
		echo " [fw up] The firewall appears to be up and running (More than $MINIMAL_AMOUNT_OF_RULES rules in kernel)."
	else
		echo " [fw down] The firewall appears to be down (Less than $MINIMAL_AMOUNT_OF_RULES rules in kernel)."
	fi

	if [ $vars_ipset_ipv4 -ne $vars_ipset_ipv6 ] || [ $vars_ipv4 -ne $vars_ipv6 ]
	then
		message " W: Please run \`fw-admin --check-datafiles' to know about datafile corruptions."
	fi

	return $retval

}

# boolean check_datafile_format(string filename)
# Check the format of a datafile
check_datafile_format()
{
	local retval=0
	# Format 1
	# #comments
	# VARIABLE=data #comment
	# VAR1ABl3= data #comment
	# blankline
	# #comments
	# VARIABLe= d4t4  ##comment

	# Format 2
	# #comments
	# VARIABLE=d4t4
	# VAR1ABLe=data
	# blankline
	# #comments
	# VARIABLE= data

	if [ ! -z "$1" ] && [ -e $1 ]
	then
		if [ "$2" == "2" ]
		then
			# format 2 without trailing comment

			# invalid lines
			local invalid_lines=`\
				cat $1 | nl -ba \
				| egrep -vE ^[[:space:]]*[0-9]+[[:space:]]+"#"\|^[[:space:]]*[0-9]+[[:space:]]*$\|^[[:space:]]*[0-9]+[[:space:]]\{1}[A-Za-z].*=+.*`
		else
			# format 1 default, with trailing comment
			# invalid lines
			local invalid_lines=`\
				cat $1 | nl -ba \
				| egrep -vE ^[[:space:]]*[0-9]+[[:space:]]+"#"\|^[[:space:]]*[0-9]+[[:space:]]*$\|^[[:space:]]*[0-9]+[[:space:]]\{1}[A-Za-z].*=+.*[[:space:]]+#.*$`
		fi
		if [ ! -z "$invalid_lines" ]
		then
			retval=1
			message "W: Check invalid lines detected in file ${1}:"
			echo -e "  Line  Content"
			echo "$invalid_lines"

		fi
	else
		message "E: Function check_datafile_format() called with bad arguments."
		do_exit 1
	fi
	return $retval
}

# boolean check_datafile_sanity(string filename1, string filename2)
# Check if all variables are the same in both files
check_datafile_sanity()
{
	local retval=0
	local AUX_FILE2="`mktemp`"
	local filename1=$1
	local filename2=$2

	if [ -z "$filename1" ] || [ -z "$filename2" ]
	then
		message "E: Function check_datafile_sanity() called without arguments."
		do_exit 1
	fi

	if [ ! -r "$filename1" ] || [ ! -r "$filename2" ]
	then
		message "E: Unable to read $filename1 or $filename2."
		do_exit 1
	fi

	egrep -v ^[[:space:]]*#\|^[[:space:]]*$ $filename1 | awk -F'=' '{print $1}' | sort -n | sort -u > $AUX_FILE
	egrep -v ^[[:space:]]*#\|^[[:space:]]*$ $filename2 | awk -F'=' '{print $1}' | sort -n | sort -u > $AUX_FILE2
	result=`diff $AUX_FILE $AUX_FILE2`
	if [ ! -z "$result" ]
	then
		retval=1
		if [[ "$result" =~ ">" ]]
		then
			message "W: Missing variables in $filename1 from $filename2"
			grep ">" <<< "$result"
		fi
		if [[ "$result" =~ "<" ]]
		then
			message "W: Missing variables in $filename2 from $filename1"
			grep "<" <<< "$result"
		fi
	fi
	rm -rf $AUX_FILE2 2>/dev/null
	return $retval
}

# boolean check_datafile_unset_variables(string datafile)
# check and print warnings for unset variables in datafiles
check_datafile_unset_variables()
{
	local check_datafile_unset_variables_retval=0

	local datafile=$1

	if [ ! -r "$datafile" ]
	then
		message "E: Error in function check_datafile_unset_variables(), unable to read file $datafile"
		do_exit 1
	fi

	# The warning trick
	set -u
	error_msg=$( source $datafile 2>&1 )
	if [ $? -ne 0 ]
	then
		check_datafile_unset_variables_retval=1
		message "W: Unset variables found in $datafile"

		oldIFS=$IFS ; IFS=$'\n' # Control over IFS
		for line in $error_msg
		do
			echo " $line" >&2
		done
		IFS=$oldIFS
	fi
	# Revert the warning trick
	set +u

	return $check_datafile_unset_variables_retval
}

# boolean check_duplicate_variables(string filename)
# Check if there are duplicate variables in a given filename
check_duplicate_variables()
{
	local check_duplicate_variables_retval=1
	local filename=$1

	local result=$( grep -v '^[[:space:]]*#|^[[:space:]]*$' $filename 2>/dev/null | awk -F'=' '{print $1}' | sort -n | uniq -D )
	if [ -z "$result" ]
	then
		check_duplicate_variables_retval=0
	else
		message "W: Detected duplicate variables in datafile $filename"
		sort -u <<< "$result"
	fi

	return $check_duplicate_variables_retval
}

# boolean check_duplicate_ipset_ip_variables()
# Check possible variables with the same name in both types of datafiles
check_duplicate_ipset_ip_variables()
{
	local check_duplicate_ipset_ip_variables_retval=1

	list_of_ip_variables=$( { awk -F'=' '{print $1}' $VARS_IPV4 ; awk -F'=' '{print $1}' $VARS_IPV6 ; } | egrep -v ^[[:space:]]*#\|^[[:space:]]*$ | sort | uniq )
	list_of_ipset_variables=$( { awk -F'=' '{print $1}' $VARS_IPSETV4 ; awk -F'=' '{print $1}' $VARS_IPSETV6 ; } | egrep -v ^[[:space:]]*#\|^[[:space:]]*$ | sort | uniq )
	result=$( comm -12 <(echo "$list_of_ip_variables") <(echo "$list_of_ipset_variables") 2> /dev/null )
	if [ -z "$result" ]
	then
		check_duplicate_ipset_ip_variables_retval=0
	else
		message "W: Detected duplicate IP/IPSET variables. You may get some undesirable overrides"
		for variable in "$result"
		do
			grep ^${variable}= $DATA_DIR/*
		done
	fi

	return $check_duplicate_ipset_ip_variables_retval
}

# boolean check_datafiles()
# Check what variables are missing in what datafiles and the format is correct.
check_datafiles()
{
	local retval=0

	# Checking format 1: trailing comment
	check_datafile_format $VARS_IPV4 1 || retval=$?
	check_datafile_format $VARS_IPV6 1 || retval=$?
	# Checking format 2: no trailing comment
	check_datafile_format $VARS_IPSETV4 2 || retval=$?
	check_datafile_format $VARS_IPSETV6 2 || retval=$?

	# Checking sanity
	check_datafile_sanity $VARS_IPV4 $VARS_IPV6 || retval=$?
	check_datafile_sanity $VARS_IPSETV4 $VARS_IPSETV6 || retval=$?

	# Check duplicate variables
	check_duplicate_variables $VARS_IPV4 || retval=$?
	check_duplicate_variables $VARS_IPV6 || retval=$?
	check_duplicate_variables $VARS_IPSETV4 || retval=$?
	check_duplicate_variables $VARS_IPSETV6 || retval=$?

	# Check for unset variables
	check_datafile_unset_variables $VARS_IPV4 || retval=$?
	check_datafile_unset_variables $VARS_IPV6 || retval=$?
	check_datafile_unset_variables $VARS_IPSETV4 || retval=$?
	check_datafile_unset_variables $VARS_IPSETV6 || retval=$?

	# Check for duplicates variables from one kind of datafiles to another
	check_duplicate_ipset_ip_variables || retval=$?

	return $retval
}

# void get_input_abstracted_of_type(string data, string outputfile)
# Given a data, search datafiles and output results to outputfile.
# No matter what is the type of the data: var, ip, fqdn, whatever.
get_input_abstracted_of_type()
{
	data=$1
	outputfile=$2


	# 1º Search the data just typed
	search_datafiles $data $outputfile


	# 2º Search the variable name the data should has
	variable_name=$( get_variable_name $data )
	if [ $? -eq 0 ] && [ ! -z "$variable_name" ]
	then
		search_datafiles $variable_name $outputfile
	fi


	# 3º Search only if previous data has been found.
	# Search in base a previous data found
	#
	# Take care of the message format produced by function search_datafiles()
	# "$VARS_IPV4: ${C_BOLD}${line}${C_NORMAL}" #--> ' VAR=dato #text'
	if [ `cat $outputfile | wc -l` -gt 0 ]
	then
		oldIFS=$IFS ; IFS=$' \t\n' # Control over IFS
		# Search after comment (#)
		local new_data_search_list=`cat $outputfile | awk -F'#' '{print $2}' | awk -F' ' '{print $1}' | sort -u | uniq `
		for i in $new_data_search_list
		do
			search_datafiles $i $outputfile
		done
		# Search before (=)
		local new_data_search_list=`cat $outputfile | awk -F' ' '{print $2}' | awk -F'=' '{print $1}' | sort -u | uniq`
		for i in $new_data_search_list
		do
			search_datafiles $i $outputfile
		done
		# Seach after (=)
		local new_data_search_list=`cat $outputfile | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | sort -u | uniq`
		for i in $new_data_search_list
		do
			if [ "$i" != "\$VOID" ] || [ "$i" != "\$VOID" ]
			then
				search_datafiles $i $outputfile
			fi
		done
		IFS=$oldIFS
	fi
	return 0
}

# boolean get_information(string data)
# Search for information in datafiles, sets and iptables
get_information()
{

	local get_information_retval=1
        local data=$1
	echo -n "" > $AUX_FILE

        if [ -z "$data" ]
        then
                # No input data, use menu
                read -p "-> Define IPv4, IPv6 or FQDN: " data
        fi

	get_input_abstracted_of_type $data $AUX_FILE

 	# Querying now ipset
	local list_of_matching_sets=""
	local flag_set_added=0
	local set_list=`$IPSET -L | grep "Name:" | awk -F' ' '{print $2}' | grep -v ^[[:space:]]*$`
	oldIFS=$IFS ; IFS=$' \t\n' # Control over IFS
	for sset in $set_list
	do
		if $IPSET -T $sset $data > /dev/null 2> /dev/null
		then
			list_of_matching_sets="$list_of_matching_sets $sset"
			flag_set_added=1
		fi
		if [ $flag_set_added -eq 0 ]
		then
	                # Searching with data behind # from data already found
			for data in `cat $AUX_FILE | awk -F'#' '{print $2}' | awk -F' ' '{print $1}' | sort -u | uniq`
			do
				if $IPSET -T $sset $data > /dev/null 2> /dev/null
				then
					list_of_matching_sets="$list_of_matching_sets $sset"
					flag_set_added=1
				fi
			done
		fi
		if [ $flag_set_added -eq 0 ]
		then
			# Seach with data after (=) from data already found
			for data in `cat $AUX_FILE | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | sort -u | uniq`
			do
				if $IPSET -T $sset $data > /dev/null 2> /dev/null
				then
					list_of_matching_sets="$list_of_matching_sets $sset"
				fi
			done
		fi
	done
	IFS=$oldIFS

	# Show or not sets where data was found
	if [ ! -z "$list_of_matching_sets" ]
	then
		# Fix for printing
		list_of_sets_witch_match=`echo $list_of_matching_sets | tr ' ' '\n' | grep -v ^[[:space:]]*$ | sort -u | uniq | tr '\n' ' '`
		echo -e "I: Data ${C_BOLD}$data${C_NORMAL} is in set(s): ${list_of_matching_sets}" >> $AUX_FILE
		flag_data_shown=true
	fi


	#########################################################
	# Ordering
	if [ `cat $AUX_FILE | wc -l` -gt 0 ]
	then
		flag_data_shown=true
		cat $AUX_FILE | sort -u | while read linea
		do
			message "$linea"
		done
	fi

	echo -n "" > $AUX_FILE

	if [ ! -z "$list_of_matching_sets" ]
	then
		oldIFS=$IFS ; IFS=$' '
		for i in $list_of_matching_sets
		do
			$IPT_SAVE -c | grep "match\-set" | grep "$i" >> $AUX_FILE && flag_data_shown=true
			$IP6T_SAVE -c | grep "match\-set" | grep "$i" >> $AUX_FILE && flag_data_shown=true
		done
		IFS=$oldIFS
		local total_rules=`cat $AUX_FILE | wc -l`
		if [ $total_rules -gt 0 ]
		then
			message "I: Rules regarding related sets:"
			cat $AUX_FILE | sort -u | uniq
		fi
	fi

	local iptables_query=`grep -i $data $VARS_IPV4 | grep -v VOID | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | tr -d [:space:]` # get value
	if is_ipv4_valid $iptables_query
	then
		local rules_num_ipv4_nat=`$IPT_SAVE -t nat | grep "$iptables_query" | wc -l`
		if [ $rules_num_ipv4_nat -gt 0 ]
		then
			message "I: IPv4 (nat) rules: $rules_num_ipv4_nat"
			$IPT_SAVE -c -t nat | grep $iptables_query && flag_data_shown=true
		fi
		local ipv4_rules_num=`$IPT_SAVE | grep "$iptables_query" | wc -l`
		if [ $ipv4_rules_num -gt 0 ]
		then
			message "I: IPv4 rules: $ipv4_rules_num"
			$IPT_SAVE -c | grep $iptables_query && flag_data_shown=true
		fi
	else
		ipv4_rules_num=0
		rules_num_ipv4_nat=0
	fi
	iptables_query=`grep $data $VARS_IPV6 | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | tr -d [:space:]` # get value
	if is_ipv6_valid $iptables_query
	then
		local ipv6_rules_num=`$IP6T_SAVE | grep "$iptables_query" | wc -l`
		if [ $ipv6_rules_num -gt 0 ]
		then
			message "I: IPv6 rules: $ipv6_rules_num"
			$IP6T_SAVE -c | grep $iptables_query
			flag_data_shown=true
		fi
	else
		ipv6_rules_num=0
	fi

	total_rules=$(( rules_num_ipv4_nat + total_rules ))
	total_rules=$(( total_rules + ipv4_rules_num ))
	total_rules=$(( total_rules + ipv6_rules_num ))
	[ "$total_rules" -gt 0 ] && message "I: ${C_BOLD}${total_rules}${C_NORMAL} related rules found"


	if [ "$flag_data_shown" != "true" ]
	then
		message "W: No data found"
		get_information_retval=1
	else
		get_information_retval=0
	fi
	return $get_information_retval
}

# boolean search_datafiles(string data, string result_return_file)
# This function search for data in datafiles and return results to a file
search_datafiles()
{
	local search_datafiles_retval=1
	local data=$1 #dato a buscar
	local result_return_file=$2 #fichero al que escribir mensaje en caso de acierto

	if [ ! -z "$data" ] && [ -e "$result_return_file" ]
	then

		oldIFS=$IFS ; IFS=$'\n' # control over IFS

		local aux_data=`tr '.' '_' <<< $data | tr '-' '_'`
		for line in `egrep -i ="$data"[[:space:]]\|"#""$data"\|"$data"[[:space:]]*"="\|"$aux_data"[[:space:]]*"=" $VARS_IPV4 2>/dev/null`
		do
			search_datafiles_retval=0
			# WARNING! If you change this message, you must change also the function get_information()
			echo -e "$VARS_IPV4: ${line}" >> $2
		done
		for line in `egrep -i ="$data"[[:space:]]\|"#""$data"\|"$data"[[:space:]]*"="\|"$aux_data"[[:space:]]*"=" $VARS_IPV6 2>/dev/null`
		do
			search_datafiles_retval=0
			# WARNING! If you change this message, you must change also the function get_information()
			echo -e "$VARS_IPV6: ${line}" >> $2
		done
	else
		message "E: Function search_datafiles() called with bad arguments."
		do_exit 1
	fi

	return $search_datafiles_retval
}


# boolean check_iptables_syntax_loop(string file_being_checked, int protocol)
# Loop over a file checking iptables syntax. Protocol: 4|6
check_iptables_syntax_loop()
{

	local check_iptables_syntax_loop_retval=0
	echo -n "" > $AUX_FILE

	# Validations
	[ ! -r "$1" ] && { message "E: Function check_iptables_syntax_loop() called with an unreadable filename as argument." ; do_exit 1 ;}
	[ "$2" != "4" ] && [ "$2" != "6" ] && { message "E: Function check_iptables_syntax_loop() called with bad protocol as argument." ; do_exit 1 ; }

	# Using a more legible name
	local file_being_checked=$1
	local protocol=$2

	# Store all lines in a variable, to avoid double disk read in: calculating the amount of lines and iterate over they.
	local list_of_lines=`cat $file_being_checked | nl -b a | egrep -v ^[[:space:]]*[0-9]*[[:space:]]*"#"\|^[[:space:]]*[0-9]*[[:space:]]$\|"IPSET" | egrep "IPT -A "\|"IPT -I "`

	# Evaluating if we need calcules regarding progress bar
	if [ "$USE_PROGRESS_BAR" == "yes" ]
	then
		local amount_of_lines=`wc -l <<< "$list_of_lines"`
		local cont=0
	fi

	for line in $list_of_lines
	do
		# Evaluating if we need calcules regarding progress bar
		if [ "$USE_PROGRESS_BAR" == "yes" ]
		then
			((cont++))
			libprogressbar $cont $amount_of_lines
		fi

		# Preparing the line to be evaluated.

		# 1º Delete the number of the line
		local ejec=`awk -F' ' '{$1=""}1' <<< ${line}`
		# 2º Change -I to -C
		ejec=${ejec/"IPT -I "/"IPT -C "}
		# 3º Change -A to -C
		ejec=${ejec/"IPT -A "/"IPT -C "}

		# Evaluating now
		error_msg=$( eval "${ejec} 2>&1" 2>&1 ) # error_msg must be a global variable for this trick to work
		if [ $? -eq 2 ]
		then
			message "W: The rule in line \"`awk -F' ' '{print $1}' <<< $line`\" failed the check in IPv${protocol}." >> $AUX_FILE 2>&1
			echo "Details:" >> $AUX_FILE
			awk -F' ' '{$1=""}1' <<< ${line} >> $AUX_FILE
			# add a space to improve reading by the admin
			for error_line in $error_msg
			do
				echo " $error_line" >> $AUX_FILE
			done
			check_iptables_syntax_loop_retval=1
		fi
	done

	grep -v ^[[:space:]]*$ $AUX_FILE >&2

	return $check_iptables_syntax_loop_retval
}

# boolean check_iptables_syntax(string filename)
# Source datafiles and launch loop over rules in a given file
check_iptables_syntax()
{
	# Doing nothing if format restore
	[ "$FORMAT" == "restore" ] && return 0

	local check_iptables_syntax_retval=0
	local filename=$1

	# Doing nothing if is the $IPSET_CONF file or if it is the core file.
	if [[ "$filename" =~ ^"core"$ ]] || [[ "$filename" =~ /"core"$ ]] || [ "$filename" == "$IPSET_CONF" ]
	then
		return 0
	fi

	# EXIT POINT
	if [ ! -r "$filename" ]
	then
		message "E: Bad call to function check_iptables_syntax()"
		do_exit 1
	fi

	# Clean the aux file
	echo "" > $AUX_FILE

	# If using progress bar, print a message so user know what means.
	[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Checking iptables syntax $filename"

	oldIFS=$IFS ; IFS=$'\n' # Control over IFS
	source $VARS_IPV4 && source $VARS_IPSETV4 && { IPT=$IPT_LOCAL ; IPSET=$IPSET_LOCAL ; } \
	|| { message "E: Unable to load datafiles in IPv4." ; do_exit 1 ; } # EXIT POINT

	check_iptables_syntax_loop $filename 4 || check_iptables_syntax_retval=1

	# Aboid IPv6 checks if NAT
	if [[ $filename =~ "nat"$ ]]
	then
		: "DEBUG: No IPv6 syntax check because NAT."
	else
		message "I: Checking ip6tables syntax $filename"
		source $VARS_IPV6 && source $VARS_IPSETV6 && { IPT=$IP6T_LOCAL ; IPSET=$IPSET_LOCAL ; } \
		|| { message "E: Unable to load datafiles in IPv6." ; do_exit 1 ; } # EXIT POINT

		check_iptables_syntax_loop $filename 6 || check_iptables_syntax_retval=1
	fi
	IFS=$oldIFS
	return $check_iptables_syntax_retval
}

# boolean check_rulefile(string file_to_check)
# To check that variables of a rulefile are in datafiles and ip[6]?tables syntax
check_rulefile()
{
	[ ! -z "$flag_no_check" ] && [ $flag_no_check -eq 1 ] && return 0

	local check_rulefile_retval=0
	local flag_wrong_variables=0
	local flag_wrong_iptables=0

	local file_to_check=$( get_absolute_path $1 )
	if [ "$file_to_check" == "" ]
	then
		message "E: File not found $1"
		do_exit 1
	fi

	# Clear aux file
	echo "" > $AUX_FILE


	# If we are using progress bar, print a message so user know what means the progress bar
	[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Checking variables $file_to_check"

	oldIFS=$IFS ; IFS=$' \t\n' # control over IFS
	# Do we need to do calcules related to progress bar?
	if [ "$USE_PROGRESS_BAR" == "yes" ]
	then
		local amount=`grep -v ^[[:space:]]*# $file_to_check | tr [[:space:]] '\n' | fgrep \$ | egrep -v "IPT"$\|"IPSET"$\|^[[:space:]]*$ | sort -u | wc -l`
		local cont=0
	fi

	# Iterate over variables ($FOO) on file
	for word in `grep -v ^[[:space:]]*# $file_to_check | tr [[:space:]] '\n' | fgrep \$ | egrep -v "IPT"$\|"IPSET"$\|^[[:space:]]*$ | sort -u`
	do
		# Do we need to do calcules related to progress bar?
		if [ "$USE_PROGRESS_BAR" == "yes" ]
		then
	                ((cont++))
	       	        libprogressbar $cont $amount
		fi
		# If the word is IPT|IPSET|iptables|ip6tables, do nothing and continue
		{ [[ "$word" =~ "IPT" ]] || [[ "$word" =~ "IPSET" ]] || [[ "$word" =~ "ip"[6]?"tables" ]] ; } && continue
		# If not, look for the word in datafiles
		local search=`echo $word | tr -d '$'`

		# the search. Must be in both datafiles of the same type to consider the variable valid.
		if ! { grep ^[[:space:]]*"$search"=.*$ $VARS_IPV4 > /dev/null && grep ^[[:space:]]*"$search"=.*$ $VARS_IPV6 > /dev/null ; }
		then
			if ! { grep ^[[:space:]]*"$search"=.*$ $VARS_IPSETV4 > /dev/null && grep ^[[:space:]]*"$search"=.*$ $VARS_IPSETV6 > /dev/null ; }
			then
				echo "W: Unknow variable \$${search} $file_to_check" >> $AUX_FILE
				flag_wrong_variables=1
			fi
		fi
	done
	IFS=$oldIFS

	# Showing warnings now
	oldIFS=$IFS ; IFS=$'\n'
	for line in $( cat $AUX_FILE )
	do
		message "$line"
	done
	IFS=$oldIFS

	[ $flag_wrong_variables -ne 0 ] && return 1 # return point

	# Check iptables syntax if all variables all fine
	check_iptables_syntax $file_to_check || flag_wrong_iptables=$?
	[ "$flag_wrong_variables" -ne 0 ] || [ "$flag_wrong_iptables" -ne 0 ] && check_rulefile_retval=1

	return $check_rulefile_retval
}

# boolean check_chain_exist(string chainname)
# Check if a chain exists in iptables/6tables
check_chain_exist()
{
	local check_chain_exist_retval=1

	# validating
	[ -z "$1" ] && return 1

	# core, sets, nat doesn't require chain
	[[ $1 =~ ^"core"$|^"sets"$|^"nat"$ ]] && return 0

	if $IPT_SAVE | grep ^: | grep $1 >/dev/null 2>/dev/null
	then
		if $IP6T_SAVE | grep ^: | grep $1 >/dev/null 2>/dev/null
		then
			check_chain_exist_retval=0
		fi
	fi

	return $check_chain_exist_retval
}

################################################################
################################################################
# Operations functions

# void start_controlled_exit()
# To be used inside traps.
start_controlled_exit()
{
	echo ""

	if [ "$FLUSH_WHEN_ABORT_START" == "yes" ]
	then
		message "W: Aborting the start operation and flushing rules ${1}"
		flush_chain $1
	else
		message "W: Aborting the start operation ${1}"
	fi
	do_exit 1
}

# boolean start_in_script_format(string filename)
# Check&start rules on given vlan/filename
start_in_script_format()
{
	[ "$SHOW_OP_TIME" == "yes" ] && local initial_time=`date +%s`
	local start_retval=0
	local filename=$( get_absolute_path $1 )
	if [ "$filename" == "" ]
	then
		message "E: File not found $1"
		do_exit 1
	fi

	# Obtain vlan/chain name
	local vlan=`awk -F'/' '{print $NF}' <<< $filename`

	# Check that given chain exist
	if ! check_chain_exist $vlan
	then
		message "E: Given chain doesn't exist."
		do_exit 1 # EXIT POINT
	fi

	# Exit trap
	trap "start_controlled_exit $vlan" SIGHUP SIGINT SIGTERM SIGKILL SIGTSTP SIGQUIT SIGCONT

	# Checking rulefile.
	if ! check_rulefile $filename
	then
		message "E: Check failed. Don't starting."
		do_exit 1 # EXIT POINT
	fi

	# Deletin previous rules
	if ! flush_chain $vlan
	then
		message "E: Error flushing vlan."
		do_exit 1 # EXIT POINT
	fi

	# Starting IPv4 rules. Show the msg if USE_PROGRESS_BAR == yes because when showing the bar, you need to know what it stands for.
	[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Starting IPv4 rules"

	# Start the for loop only if success loading datafiles
	if source $VARS_IPV4 && source $VARS_IPSETV4
	then
		start_in_script_format_loop $vlan 4 || start_retval=$?
	else
		message "E: Error loading datafiles in IPv4"
		if [ "$FLUSH_WHEN_ERROR_START" == "yes" ]
		then
			flush_chain $vlan
		fi
		do_exit 1 # EXIT POINT
	fi
	delete_transaccional_rules $vlan || { message "E: Function delete_transaccional_rules() failed for IPv4" ; do_exit 1 ; } # EXIT POINT


	if grep -i nat <<< $vlan > /dev/null
	then
		: "DEBUG: Not inserting rules in IPv6 because a nat file"
	else
		# Starting IPv6 rules. Show the msg if USE_PROGRESS_BAR == yes because when showing the bar, you need to know what it stands for.
		[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Starting IPv6 rules"

		# Start the for loop only if success loading datafiles
		if source $VARS_IPV6 && source $VARS_IPSETV6
		then
			start_in_script_format_loop $vlan 6 || start_retval=$?
		else
			message "E: Error loading datafiles in IPv6"
			if [ "$FLUSH_WHEN_ERROR_START" == "yes" ]
			then
				flush_chain $vlan
			fi
			do_exit 1 # EXIT POINT
		fi
		delete_transaccional_rules $vlan || { message "E: Function delete_transaccional_rules() failed for IPv6" ; do_exit 1 ; } # EXIT POINT
	fi

	if [ "$SHOW_OP_TIME" == "yes" ]
	then
		message "I: Operation time over ${vlan}: $(( `date +%s` - initial_time )) seconds."
	fi

	return $start_retval
}

# boolean start_loop(string vlan_file, integer protocol)
# Iterate over rulefile inserting rules in kernel
start_in_script_format_loop()
{
	local start_loop_retval=0

	local vlan_file=$( get_absolute_path $1 )
	local protocol=$2

	if [ ! -r "$vlan_file" ] || [ -z "$protocol" ]
	then
		message "E: Bad call to function start_in_script_format_loop(), invalid input arguments."
		do_exit 1 # EXIT POINT
	fi

	list_of_lines=`grep -v ^[[:space:]]*# $vlan_file | grep -v ^[[:space:]]*$`

	# Evaluating if we need calcules related to the progress bar
	if [ "$USE_PROGRESS_BAR" == "yes" ]
	then
		local amount_of_lines=`wc -l <<< "$list_of_lines"`
	fi
	local cont=0


	oldIFS=$IFS ; IFS=$'\n' # control over IFS
	for line in $list_of_lines
	do
		((cont++))

		# Evaluating if we need calcules related to the progress bar
		[ "$USE_PROGRESS_BAR" == "yes" ] && [ -z "$flag_no_check" ] && libprogressbar $cont $amount_of_lines

		# Insert the rule in kernel and evaluate return code
		error_msg=$( eval "${line} 2>&1" 2>&1 ) # error_msg must be a global variable for this trick to work
		if [ $? -ne 0 ]
		then
			start_loop_retval=1
			message "W: Error found adding rules to kernel in IPv${protocol}. Rule num (not line) $cont $vlan_file"
			echo "Details:"
			echo " ${line}"
			for error_line in $error_msg
			do
				echo " $error_line"
			done

			# Behaviour when error at start operation
			#FLUSH_WHEN_ERROR_START="no"

			if [ "$FLUSH_WHEN_ERROR_START" == "yes" ]
			then
				message "W: Flushing rules $vlan ..."
				flush_chain $vlan
				do_exit 1 # EXIT POINT
			fi
		fi
	done
	IFS=$oldIFS

	return $start_loop_retval
}

# boolean flush_chain(string chain)
# flush rules and add permissive rules if selected
flush_chain()
{
	local flush_chain_retval=0

	local chain=$1

	if [ ! -z "$chain" ]
	then
		if [[ $chain =~ ^"core" ]]
		then
			# Flushing entire firewall
			$IPT_LOCAL -F 2>/dev/null || flush_chain_retval=1
			$IPT_LOCAL -F -t nat 2>/dev/null || flush_chain_retval=1
			$IPT_LOCAL -X 2>/dev/null || flush_chain_retval=1
			$IP6T_LOCAL -F 2>/dev/null || flush_chain_retval=1
			$IP6T_LOCAL -X 2>/dev/null || flush_chain_retval=1

			if [ "$PERMISSIVE_TRAFFIC_WHEN_STOP" == "yes" ]
			then
				$IPT_LOCAL -A FORWARD -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
				$IPT_LOCAL -A INPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
				$IPT_LOCAL -A OUTPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
				$IP6T_LOCAL -A FORWARD -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
				$IP6T_LOCAL -A INPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
				$IP6T_LOCAL -A OUTPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
			fi
		else
			if [[ $chain =~ "nat" ]]
			then
				# Flushing nat rules
				$IPT_LOCAL -F -t nat 2>/dev/null || flush_chain_retval=1
			else
				# No nat rules
				$IPT_LOCAL -F $chain 2>/dev/null || flush_chain_retval=1
				$IP6T_LOCAL -F $chain 2>/dev/null || flush_chain_retval=1

				if [ "$PERMISSIVE_TRAFFIC_WHEN_STOP" == "yes" ]
				then
					$IPT_LOCAL -A $chain -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
					$IP6T_LOCAL -A $chain -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2>/dev/null || flush_chain_retval=1
				fi
			fi
		fi
	else
		flush_chain_retval=1
	fi
	return $flush_chain_retval
}

delete_transaccional_rules()
{
	local delete_transaccional_rules_retval=0
	local cont=0

	# Recibe como parametro una vlan o nat
	if [ ! -z "$1" ]
	then
		if grep -i core <<< $1 > /dev/null
		then
			while $IPT -C FORWARD -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null
			do
				# avoid infitine loop
				[ $cont -gt 1000 ] && break
				(( cont++ ))

				$IPT -D FORWARD -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null \
					|| message "W: Unable to remove transaccional rule (forward)."
			done

			cont=0
			while $IPT -C INPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null
			do
				# avoid infitine loop
				[ $cont -gt 1000 ] && break
				(( cont++ ))

				$IPT -D INPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null \
					|| message "W: Unable to remove transaccional rule (input)."
			done
			cont=0
			while $IPT -C OUTPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null
			do
				# avoid infitine loop
				[ $cont -gt 1000 ] && break
				(( cont++ ))

				$IPT -D OUTPUT -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null \
					|| message "W: Unable to remove transaccional rule (output)."
			done
		else
			if ! grep -i nat <<< $1 > /dev/null
			then
				cont=0
				while $IPT -C $1 -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null
				do
					# avoid infitine loop
					[ $cont -gt 1000 ] && break
					(( cont++ ))
					$IPT -D $1 -m comment --comment "transaccional_rule_fw-admin" -j ACCEPT 2> /dev/null \
						|| message "W: Unable to remove transaccional rule $1"
				done
			fi
		fi
	else
		delete_transaccional_rules_retval=1
	fi
	return $delete_transaccional_rules_retval
}

# boolean stop_in_restore_format()
# Flush ruleset
# for FORMAT=ruleset
stop_in_restore_format()
{
	local stop_in_ruleset_format_retval=0

	message "W: Flushing all rules."

	flush_chain core || stop_in_ruleset_format_retval=$?

	return $stop_in_ruleset_format_retval
}

# boolean stop_in_script_format(string chain)
# Used to stop rules of the given chain name
# for FORMAT=script
stop_in_script_format()
{
	local stop_in_script_format_retval=0

	local chain=$1

	if check_chain_exist $chain
	then
		flush_chain $chain || stop_in_script_format_retval=1
	else
		message "E: Chain doesn't exist $chain"
		do_exit 1
	fi

	if [ $stop_in_script_format_retval -ne 0 ]
	then
		message "E: Unable to flush rules $chain"
		do_exit 1
	fi

	return $stop_in_script_format_retval
}

# void ipset_reload_controlled_exit()
# Handle the exit trap of ipset_reload()
ipset_reload_controlled_exit()
{
	echo ""
	message "W: Reload aborted"
	do_exit 1
}

# boolean ipset_reload()
# Check and reload ipset data
ipset_reload()
{
	[ "$SHOW_OP_TIME" == "yes" ] && local start_time="`date +%s`"

	# Trap for abort operation
	trap "ipset_reload_controlled_exit " SIGHUP SIGINT SIGTERM SIGKILL SIGTSTP SIGQUIT SIGCONT

	local ipset_reload_retval=0

	# Checkear el fichero de IPSET
	check_rulefile $IPSET_CONF || return $?


	[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Reloading now IPset IPv4 data"

	# Flushing SETS
	$IPSET_LOCAL x 2>/dev/null

	#
	# Now IPv4
	#
	source $VARS_IPV4 && source $VARS_IPSETV4 \
		|| { message "E: Unable to load IPv4 datafiles." ; do_exit 1 ; }

	if [ $ipset_reload_retval -eq 0 ]
	then
		ipset_reload_loop IPv4
	fi

	#
	# Now IPv6
	#
	[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Reloading now IPset IPv6 data"

	source $VARS_IPV6 && source $VARS_IPSETV6 \
		|| { message "E: Unable to load IPv6 datafiles." ; do_exit 1 ; }
	if [ $ipset_reload_retval -eq 0 ]
	then
		ipset_reload_loop IPv6
	fi

	if [ "$SHOW_OP_TIME" == "yes" ]
	then
	        message "I: Operation time: $(( `date +%s` - $start_time )) seconds."
	fi

	return $ipset_reload_retval
}

# boolean ipset_reload_loop(string protocol)
# Iterate over the ipset config file. Protocol={IPv4|IPv6}
ipset_reload_loop()
{
	local protocol=$1
	# We are going to iterate over the list of lines
	local list_of_lines=$( grep -v ^[[:space:]]*# $IPSET_CONF | grep -v ^[[:space:]]*$ )

	local cont=0
	# evaluating in we need calcules related to the progress bar
	[ "$USE_PROGRESS_BAR" == "yes" ] && local amount_of_lines=$( wc -l <<< "$list_of_lines" )

	oldIFS=$IFS ; IFS=$'\n' # Controls over IFS
	for linea in $list_of_lines
	do
		((cont++))
		# evaluating in we need calcules related to the progress bar
		[ "$USE_PROGRESS_BAR" == "yes" ] && [ -z "$flag_no_check" ] && libprogressbar $cont $amount_of_lines

		# Evaluate the line of the file.
		error_msg=$( eval "${linea} 2>&1" 2>&1 )
		if [ $? -ne 0 ]
		then
			message "E: Error found reloading sets in ${protocol}. Rule num (not line) $cont"
			echo "Details:"
			echo " ${linea}"
			for line in $error_msg
			do
				echo " $line"
			done
			do_exit 1
		fi
	done
	IFS=$oldIFS # Controls over IFS
}

# boolean start_in_restore_format_loop(string filename, string protocol)
# Iterate over a file with iptables-restore format, doing variable replacement
# and initialization.
# protocol=ipv4|ipv6
start_in_restore_format_loop()
{
	local start_in_restore_format_loop_retval=0
	local filename=$( get_absolute_path $1 )
	local protocol=$2

	if [ ! -r "$filename" ]
	then
		message "E: File not found $filename"
		do_exit 1
	fi

	case "$protocol" in
		ipv4)
			source $VARS_IPV4 || return 1
			source $VARS_IPSETV4 || return 1
			;;
		ipv6)
			source $VARS_IPV6 || return 1
			source $VARS_IPSETV6 || return 1
			;;
		*)
			message "E: Bad call to function start_in_restore_format_loop()."
			do_exit 1
	esac

	local rules=""
	case "$protocol" in
		ipv4)
			# Keep the file in ram, so avoid overloading the HD
			rules=$( cat $filename )
			;;
		ipv6)
			# Keep the file in ram, so avoid overloading the HD
			# Delete nat stuff, as is not supported... yet
			rules=$( delete_nat_from_ruleset $filename )
			# If deleting nat stuff failed, use the entire ruleset and let iptables-restore throw the error later
			[ $? -ne 0 ] && rules=$( cat $filename )
			;;
	esac

	# Iterate over variables ($FOO) on file
	local list_of_words=`grep -v ^[[:space:]]*# $filename | tr [[:space:]] '\n' | fgrep \$ | sort -u | grep -v ^[[:space:]]*$`

	if [ "$USE_PROGRESS_BAR" == "yes" ]
	then
		local amount_of_words=`wc -l <<< "$list_of_words"`
		local cont=0
	fi

	for word in $list_of_words
	do

		if [ "$USE_PROGRESS_BAR" == "yes" ]
		then
			((cont++))
			libprogressbar $cont $amount_of_words
		fi

		variable=$word
		data=`eval "echo $word"`
		data=$( echo $data | sed -e 's/\//\\\//g' ) #cleaning /
		rules=$( sed s/"$variable"/"$data"/g <<< "$rules" 2>&1)
		if [ $? -ne 0 ]
		then
			message "E: Errors found trying to replace with \`sed' the variable $variable in $protocol"
			echo "Details:" >&2
			echo " $rules" >&2
			return 1
		fi
	done


	# The loading operation is slow for rulesets bigger than 10K rules...
	# Maybe adding a progressbar here would be nice
	# but has to be while iptables-restore is running in background

	case "$protocol" in
		ipv4)
			error_msg=$( $IPT_RESTORE <<< "$rules" 2>&1 )
			if [ $? -ne 0 ]
			then
				message "E: Unable to load IPv4 ruleset."
				echo "Details:" >&2
				oldIFS=$IFS ; IFS=$'\n' #control over IFS
				for line in $error_msg
				do
					echo " $line" >&2
				done
				IFS=$oldIFS
				start_in_restore_format_loop_retval=1
			fi
			;;
		ipv6)
			# Maybe the NAT stuff was not deleted previously, so this is likely throwing errors
			error_msg=$( $IP6T_RESTORE <<< "$rules" 2>&1 )
			if [ $? -ne 0 ]
			then
				message "E: Unable to load IPv6 ruleset."
				echo "Details:" >&2
				oldIFS=$IFS ; IFS=$'\n' #control over IFS
				for line in $error_msg
				do
					echo " $line" >&2
				done
				IFS=$oldIFS
				start_in_restore_format_loop_retval=1
			fi
			;;
	esac

	return $start_in_restore_format_loop_retval
}

# text delete_nat_from_ruleset(string filename)
# Delete all from *nat to COMMIT to have the ruleset ip6tables compliant
delete_nat_from_ruleset()
{
	local delete_nat_from_ruleset_retval=0
	local filename=$( get_absolute_path $1 )

	if [ ! -r "$filename" ]
	then
		message "E: Function delete_nat_from_ruleset() called with invalid argument. File not found."
		do_exit 1
	fi

	# I saw in other code another implementation of this, more efficient. Lets see..

	local headingline=$( nl -ba $filename | grep -i ^[[:space:]]*[0-9]*[[:space:]]*"\*"nat | awk -F' ' '{print $1}' 2>/dev/null )
	[[ $headingline =~ ^[0-9]$ ]] || delete_nat_from_ruleset_retval=1

	if [ $delete_nat_from_ruleset_retval -eq 0 ]
	then
		# continue calcules
		local list_of_tailingline=$( nl -ba $filename | grep ^[[:space:]]*[0-9]*[[:space:]]"COMMIT"$ | awk -F' ' '{print $1}' | tr '\n' ' ' 2>/dev/null )

		# Calculate now what COMMIT line belongs to nat declaration
		oldIFS=$IFS ; IFS=$' ' #control over IFS
		local max_difference=$( wc -l $filename | cut -d' ' -f 1)
		for num in $list_of_tailingline
		do
			local difference=$(( num - headingline ))
			if [ $difference -lt $max_difference ]
			then
				max_difference=$difference
				tailingline=$num
			fi
		done
		IFS=$oldIFS
		# When the for is over, whe know tailingline and headingline
		sed ${headingline},${tailingline}d $filename # this is the text return
		delete_nat_from_ruletes_retval=$?
	fi

	return $delete_nat_from_ruleset_retval
}

# boolean start_in_restore_format(string filename)
start_in_restore_format()
{

	[ "$SHOW_OP_TIME" == "yes" ] && local initial_time=`date +%s`

	local start_in_restore_format_retval=0
	local filename=$( get_absolute_path $1 )

	if [ ! -r "$filename" ]
	then
		message "E: File not found $filename"
		do_exit 1
	fi

	# Set trap
	trap "start_controlled_exit core" SIGHUP SIGINT SIGTERM SIGKILL SIGTSTP SIGQUIT SIGCONT

	# Checking rulefile.
	if ! check_rulefile $filename
	then
		message "E: Check failed. Don't starting."
		do_exit 1 # EXIT POINT
	fi

	# Start IPv4
	[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Starting IPv4 ruleset"
	if ! start_in_restore_format_loop $filename ipv4
	then
		start_in_restore_format_retval=$?
		message "W: Errors found loading IPv4 ruleset $filename"
		if [ "$FLUSH_WHEN_ERROR_START" == "yes" ]
		then
			# do something to counter the fail
			flush_chain "core"
		fi
	fi

	# Start IPv6
	[ "$USE_PROGRESS_BAR" == "yes" ] && message "I: Starting IPv6 ruleset"
	if ! start_in_restore_format_loop $filename ipv6
	then
		start_in_restore_format_retval=$?
		message "W: Errors found loading IPv6 ruleset $filename"
		if [ "$FLUSH_WHEN_ERROR_START" == "yes" ]
		then
			# do something to counter the fail
			flush_chain "core"

		fi
	fi

	# Finishing
	if [ "$SHOW_OP_TIME" == "yes" ]
	then
		message "I: Operation time: $(( `date +%s` - initial_time )) seconds."
	fi

	return $start_in_restore_format_retval
}

# (@_@)
