#!/bin/bash

# Arturo Borrero <aborrero@cica.es>
#
# Copyright (c) 2013 Arturo Borrero
# This file is released under the GPLv3 license.
#
# Can obtain a complete copy of the license at: http://www.gnu.org/licenses/gpl-3.0.html
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

################################################################
################################################################
# Utilities functions

# void print_bytes_count(int bytecount)
# Used to print bytes count in a human-readable way
print_bytes_count()
{
	local bytecount=$1
	[ $bytecount -ge 9663676416 ] && { echo "$(( bytecount / 1073741824 )) GB" ; return 0 ; }
	[ $bytecount -ge 9437184 ] && { echo "$(( bytecount /  1048576 )) MB" ; return 0 ; }
	[ $bytecount -ge 9216 ] && { echo "$(( bytecount /  1024 )) kB" ; return 0 ; }
	echo "$bytecount B"

	return 0
}

# void print_bytes(int[] data)
# Used to validate and print data to user
print_bytes()
{
	if [ ! -z "$1" ] && [[ $1 =~ ^[0-9]+$ ]]
	then
		print_bytes_count $1
	else
		echo "no data"
	fi
	return 0
}


# int get_iptables_number_of_rules()
# Return how many iptables rules are inserted in the kernel
get_iptables_number_of_rules()
{
	$IPT_SAVE 2>/dev/null | grep ^- 2>/dev/null | wc -l 2>/dev/null
	return 0
}

# int get_ip6tables_number_of_rules()
# Return how many ip6tables rules are inserted in the kernel
get_ip6tables_number_of_rules()
{
	$IP6T_SAVE 2>/dev/null | grep ^- 2>/dev/null | wc -l 2>/dev/null
	return 0
}

# int get_rules_mem_usage()
# Return how many mem is being used by rules
get_rules_mem_usage()
{
	[ ! -r $VMALLOCINFO ] && return 1

	local acum=0
	for i in `egrep x_tables\|xt_ $VMALLOCINFO 2>/dev/null | awk -F' ' '{print $2}' 2>/dev/null`
	do
		[[ $i =~ ^[0123456789]+$ ]] || i=0
		acum=$(( acum + i ))
	done
	echo "$acum"

	return 1
}

# int get_ipset_number_of_sets()
# Return how many sets are inserted in the kernel
get_ipset_number_of_sets()
{
	[ ! -x $IPSET ] && return 1
	$IPSET list -n 2>/dev/null | wc -l 2>/dev/null
	return 0
}

# int get_ipset_mem_usage()
# Return how many memory is using ipset
get_ipset_mem_usage()
{
	[ ! -x $IPSET ] && return 1
	local acum=0
	for i in `$IPSET list -terse 2>/dev/null | grep memory | cut -d ' ' -f 4`
	do
		[[ $i =~ ^[0123456789]+$ ]] || i=0
		acum=$(( acum + i )) 2>/dev/null
	done
	echo "$acum"
	return 0
}

# int get_modules_mem_usage()
# Return how many memory is being used by netfilter modules
get_modules_mem_usage()
{
	[ ! -x $LSMOD ] && return 1
	local acum=0
	local oldIFS=$IFS
	IFS=$'\n'
	for i in `$LSMOD | egrep "ip_set"\|"ipt_"\|"xt_"\|"nf_"\|"ip6t_" | awk -F' ' '{print $2}'`
	do
		[[ $i =~ ^[0123456789]+$ ]] || i=0
		acum=$(( acum + i ))
	done
	IFS=$oldIFS
	echo "$acum"
	return 0
}


# int get_conntrack_mem_usage()
# Return how many mem is used by conntrack system
get_conntrack_mem_usage()
{
	[ ! -r $SLABINFO ] && return 1
	[ ! -x $GETCONF ] && return 1
	local num_objs=0
	local objs_per_slab=0
	local pages_per_slab=0
	local total_conntrack_mem_use=0
	local page_size=`$GETCONF PAGESIZE`
	local oldIFS=$IFS
	IFS=$'\n'
	for line in `grep conntrack $SLABINFO 2>/dev/null`
	do
		[ -z "$line" ] && continue
		num_objs=`echo $line | awk -F' ' '{print $3}'`
		[[ $num_objs =~ ^[0123456789]+$ ]] || num_objs=0
		objs_per_slab=`echo $line | awk -F' ' '{print $4}'`
		[[ $objs_per_slab =~ ^[0123456789]+$ ]] || objs_per_slab=1
		pages_per_slab=`echo $line | awk -F' ' '{print $5}'`
		[[ $pages_per_slab =~ ^[0123456789]+$ ]] || pages_per_slab=1
		num_used_slabs=$(( num_objs / objs_per_slab ))
		[ $num_used_slabs -le 0 ] && num_used_slabs=1
		conntrack_mem_use=$(( num_used_slabs * page_size ))
		conntrack_mem_use=$(( conntrack_mem_use * pages_per_slab ))
		total_conntrack_mem_use=$(( total_conntrack_mem_use + conntrack_mem_use ))
	done
	IFS=$oldIFS
	echo $total_conntrack_mem_use
	return 0
}


# boolean stats()
# Print stats to stdout.
stats()
{
	local retval=0

	# Info iptables
	echo -e "### About iptables  \tIPv4\tIPv6\ttotal"
	local num_of_ipv4_rules=$( get_iptables_number_of_rules )
	local num_of_ipv6_rules=$( get_ip6tables_number_of_rules )
	local num_of_ipv4_rules_nomatch=$( $IPT_SAVE -c 2>/dev/null | grep ^"\[0:0\]" | wc -l )
	local num_of_ipv6_rules_nomatch=$( $IP6T_SAVE -c 2>/dev/null | grep ^"\[0:0\]" | wc -l )

	[[ $num_of_ipv4_rules =~ ^[0-9]+$ ]] || num_of_ipv4_rules=0
	[[ $num_of_ipv6_rules =~ ^[0-9]+$ ]] || num_of_ipv6_rules=0
	[[ $num_of_ipv4_rules_nomatch =~ ^[0-9]+$ ]] || num_of_ipv4_rules_nomatch=0
	[[ $num_of_ipv6_rules_nomatch =~ ^[0-9]+$ ]] || num_of_ipv6_rules_nomatch=0


	local num_of_ipv4_rules_match=$(( num_of_ipv4_rules - num_of_ipv4_rules_nomatch ))
	local num_of_ipv6_rules_match=$(( num_of_ipv6_rules - num_of_ipv6_rules_nomatch ))
	[[ $num_of_ipv4_rules_match =~ ^[0-9]+$ ]] || num_of_ipv4_rules_match=0
	[[ $num_of_ipv6_rules_match =~ ^[0-9]+$ ]] || num_of_ipv6_rules_match=0
	local total_num_of_rules=$(( num_of_ipv4_rules + num_of_ipv6_rules ))

	echo -e " Rules with match: \t $(( num_of_ipv4_rules_match )) \t $(( num_of_ipv6_rules_match )) \t $(( num_of_ipv4_rules_match + num_of_ipv6_rules_match ))"
	echo -e " Rules not in use: \t $num_of_ipv4_rules_nomatch \t $num_of_ipv6_rules_nomatch \t $(( num_of_ipv4_rules_nomatch + num_of_ipv6_rules_nomatch ))"
	echo -e " Amount of rules: \t $num_of_ipv4_rules \t $num_of_ipv6_rules \t $total_num_of_rules"
	echo " Use and default policy IPv4:"
	$IPT -n -L -v 2>/dev/null | grep policy | while read linea
	do
		echo -e "\t$linea"
	done
	echo " Use and default policy IPv6:"
	$IP6T -n -L -v 2>/dev/null | grep policy | while read linea
	do
		echo -e "\t$linea"
	done
	echo " Hash of the ruleset: `( { $IPT_SAVE 2>/dev/null ; $IP6T_SAVE 2>/dev/null; } | grep ^"-" | md5sum | awk -F' ' '{print $1}' ) || echo error! `"

	echo ""

	# Info ipset
	echo -e "### About ipset"
	local num_of_sets=`$IPSET list -n 2>/dev/null | wc -l`

	[[ $num_of_sets =~ ^[0-9]+$ ]] || num_of_sets=0

	local num_of_sets_nomatch=`$IPSET list 2>/dev/null | grep "References: 0" | wc -l`

	[[ $num_of_sets_nomatch =~ ^[0-9]+$ ]] || num_of_sets_nomatch=0

	echo -e " Sets referenced by rules: \t $(( num_of_sets - num_of_sets_nomatch ))"
	echo -e " Sets not referenced by rules: \t $num_of_sets_nomatch"
	echo -e " Sets in kernel: \t\t $num_of_sets"

	echo ""

	# Other info
	echo -e "### About datafiles\t\tIPv4\tIPv6"
	local vars_ipv4=`grep \= $VARS_IPV4 2>/dev/null | wc -l`
	local vars_ipv6=`grep \= $VARS_IPV6 2>/dev/null | wc -l`
	local vars_ipset_ipv4=`grep \= $VARS_IPSETV4 2>/dev/null | wc -l`
	local vars_ipset_ipv6=`grep \= $VARS_IPSETV6 2>/dev/null | wc -l`
	echo -e " Declared iptables variables:\t $vars_ipv4 \t $vars_ipv6"
	echo -e " Declared ipset variables:\t $vars_ipset_ipv4 \t $vars_ipset_ipv6"
	echo ""

	echo -e "### About system"

	echo -en " Rules memory usage: \t\t\t"
	rules_mem_usage=$( get_rules_mem_usage )
	print_bytes $rules_mem_usage
	echo -en " Average memory usage per rule: \t"
	if [ $total_num_of_rules -eq 0 ]
	then
		echo "no data"
	else
		print_bytes $(( rules_mem_usage / total_num_of_rules ))
	fi
	echo -en " Ipset memory usage: \t\t\t"
	ipset_mem_usage=$( get_ipset_mem_usage )
	print_bytes $ipset_mem_usage
	echo -en " Netfilter modules memory usage: \t"
	modules_mem_usage=$( get_modules_mem_usage )
	print_bytes $modules_mem_usage
	# Conntrack config
	echo -en " Conntrack max connections to track: \t"
	egrep ^[0123456789]+$ $CONNTRACK_MAX 2>/dev/null || echo "no data"

	# Conntrack hash size
	echo -en " Conntrack hashsize: \t\t\t"
	egrep ^[0123456789]+$ $CONNTRACK_HASHSIZE 2>/dev/null || echo "no data"

	# Conntrack status
	echo -en " Number of tracked connections: \t"
	egrep ^[0123456789]+$ $CONNTRACK_COUNT 2>/dev/null || echo "no data"

	# Conntrack mem usage
	echo -en " Conntrack memory usage: \t\t"
	conntrack_mem_usage=$( get_conntrack_mem_usage )
	print_bytes $conntrack_mem_usage
	# Total mem usage
	echo -en " Total netfilter memory usage: \t\t"
	nf_mem_usage=$(( conntrack_mem_usage + modules_mem_usage ))
	nf_mem_usage=$(( nf_mem_usage + ipset_mem_usage ))
	nf_mem_usage=$(( nf_mem_usage + rules_mem_usage ))
	print_bytes $nf_mem_usage

	echo -en " System physical memory percentage [%]: "
	total_system_mem=`$FREE -b | grep Mem: | awk -F' ' '{print $2}'`
	echo -n -- | awk "{print 100 * $nf_mem_usage / $total_system_mem }" 2>/dev/null || echo "no data"

	echo ""

	if [ $num_of_ipv4_rules -ge $MINIMAL_AMOUNT_OF_RULES ] || [ $num_of_ipv6_rules -ge $MINIMAL_AMOUNT_OF_RULES ] \
	|| [ $total_num_of_rules -ge $MINIMAL_AMOUNT_OF_RULES ]
	then
		echo " [fw up] Appears to be up and running (More than $MINIMAL_AMOUNT_OF_RULES rules in kernel)."
	else
		echo " [fw down] Appears to be down (Less than $MINIMAL_AMOUNT_OF_RULES rules in kernel)."
	fi

	if [ $vars_ipset_ipv4 -ne $vars_ipset_ipv6 ] || [ $vars_ipv4 -ne $vars_ipv6 ]
	then
		message " W: Please run \`fw-admin --check-datafiles' to know about datafile corruptions."
	fi

	return $retval

}

# boolean check_datafile_format(string filename)
# Check the format of a datafile
check_datafile_format()
{
	local retval=0
	# Format 1
	# #comments
	# VARIABLE=data #comment
	# VAR1ABl3= data #comment
	# blankline
	# #comments
	# _VARIABLE=data
	# VARIABLe= d4t4  ##comment

	# Format 2
	# #comments
	# VARIABLE=d4t4
	# VAR1ABLe=data
	# blankline
	# #comments
	# _VARIABLE=data
	# VARIABLE= data

	if [ ! -z "$1" ] && [ -e $1 ]
	then
		if [ "$2" == "2" ]
		then
			# format 2 without trailing comment
			# invalid lines
			local invalid_lines=$( nl -ba $1 | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]+"#" | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]*$ | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]\{1}[A-Za-z].*=+.* | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]"_"\{1}[0-9A-Za-z].*=+.* | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]"__"\{1}[0-9A-Za-z].*=+.* )
		else
			# format 1 default, with trailing comment
			# invalid lines
			local invalid_lines=$( nl -ba $1 | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]+"#" | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]*$ | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]\{1}[A-Za-z].*=+.*[[:space:]]+#.*$ | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]"_"\{1}[0-9A-Za-z].*=+.*[[:space:]]+#.*$ | \
				egrep -vE ^[[:space:]]*[0-9]+[[:space:]]"__"\{1}[0-9A-Za-z].*=+.*[[:space:]]+#.*$ )
		fi
		if [ ! -z "$invalid_lines" ]
		then
			retval=1
			message "W: Check invalid lines detected in file ${1}:"
			echo -e "  Line  Content"
			echo "$invalid_lines"

		fi
	else
		message "E: Function check_datafile_format() called with bad arguments."
		do_exit 1
	fi
	return $retval
}

# boolean check_datafile_sanity(string filename1, string filename2)
# Check if all variables are the same in both files
check_datafile_sanity()
{
	local retval=0
	local AUX_FILE2="`mktemp`"
	local filename1=$1
	local filename2=$2

	if [ -z "$filename1" ] || [ -z "$filename2" ]
	then
		message "E: Function check_datafile_sanity() called without arguments."
		do_exit 1
	fi

	if [ ! -r "$filename1" ] || [ ! -r "$filename2" ]
	then
		message "E: Unable to read $filename1 or $filename2."
		do_exit 1
	fi

	egrep -v ^[[:space:]]*#\|^[[:space:]]*$ $filename1 | awk -F'=' '{print $1}' | sort -n | sort -u > $AUX_FILE
	egrep -v ^[[:space:]]*#\|^[[:space:]]*$ $filename2 | awk -F'=' '{print $1}' | sort -n | sort -u > $AUX_FILE2
	result=`diff $AUX_FILE $AUX_FILE2`
	if [ ! -z "$result" ]
	then
		retval=1
		if [[ "$result" =~ ">" ]]
		then
			message "W: Missing variables in $filename1 from $filename2"
			grep ">" <<< "$result"
		fi
		if [[ "$result" =~ "<" ]]
		then
			message "W: Missing variables in $filename2 from $filename1"
			grep "<" <<< "$result"
		fi
	fi
	rm -rf $AUX_FILE2 2>/dev/null
	return $retval
}

# boolean check_datafile_unset_variables(string datafile)
# check and print warnings for unset variables in datafiles
check_datafile_unset_variables()
{
	local check_datafile_unset_variables_retval=0

	local datafile=$1

	if [ ! -r "$datafile" ]
	then
		message "E: Error in function check_datafile_unset_variables(), unable to read file $datafile"
		do_exit 1
	fi

	# The warning trick
	set -u
	error_msg=$( source $datafile 2>&1 )
	if [ $? -ne 0 ]
	then
		check_datafile_unset_variables_retval=1
		message "W: Unset variables found in $datafile"

		oldIFS=$IFS ; IFS=$'\n' # Control over IFS
		for line in $error_msg
		do
			echo " $line" >&2
		done
		IFS=$oldIFS
	fi
	# Revert the warning trick
	set +u

	return $check_datafile_unset_variables_retval
}

# boolean check_duplicate_variables(string filename)
# Check if there are duplicate variables in a given filename
check_duplicate_variables()
{
	local check_duplicate_variables_retval=1
	local filename=$1

	local result=$( grep -v '^[[:space:]]*#|^[[:space:]]*$' $filename 2>/dev/null | awk -F'=' '{print $1}' | sort -n | uniq -D )
	if [ -z "$result" ]
	then
		check_duplicate_variables_retval=0
	else
		message "W: Detected duplicate variables in datafile $filename"
		sort -u <<< "$result"
	fi

	return $check_duplicate_variables_retval
}

# boolean check_duplicate_ipset_ip_variables()
# Check possible variables with the same name in both types of datafiles
check_duplicate_ipset_ip_variables()
{
	local check_duplicate_ipset_ip_variables_retval=1

	list_of_ip_variables=$( { awk -F'=' '{print $1}' $VARS_IPV4 ; awk -F'=' '{print $1}' $VARS_IPV6 ; } | egrep -v ^[[:space:]]*#\|^[[:space:]]*$ | sort | uniq )
	list_of_ipset_variables=$( { awk -F'=' '{print $1}' $VARS_IPSETV4 ; awk -F'=' '{print $1}' $VARS_IPSETV6 ; } | egrep -v ^[[:space:]]*#\|^[[:space:]]*$ | sort | uniq )
	result=$( comm -12 <(echo "$list_of_ip_variables") <(echo "$list_of_ipset_variables") 2> /dev/null )
	if [ -z "$result" ]
	then
		check_duplicate_ipset_ip_variables_retval=0
	else
		message "W: Detected duplicate IP/IPSET variables. You may get some undesirable overrides"
		for variable in "$result"
		do
			grep ^${variable}= $DATA_DIR/*
		done
	fi

	return $check_duplicate_ipset_ip_variables_retval
}

# boolean check_datafiles()
# Check what variables are missing in what datafiles and the format is correct.
check_datafiles()
{
	local retval=0

	# Checking format 1: trailing comment
	check_datafile_format $VARS_IPV4 1 || retval=$?
	check_datafile_format $VARS_IPV6 1 || retval=$?
	# Checking format 2: no trailing comment
	check_datafile_format $VARS_IPSETV4 2 || retval=$?
	check_datafile_format $VARS_IPSETV6 2 || retval=$?

	# Checking sanity
	check_datafile_sanity $VARS_IPV4 $VARS_IPV6 || retval=$?
	check_datafile_sanity $VARS_IPSETV4 $VARS_IPSETV6 || retval=$?

	# Check duplicate variables
	check_duplicate_variables $VARS_IPV4 || retval=$?
	check_duplicate_variables $VARS_IPV6 || retval=$?
	check_duplicate_variables $VARS_IPSETV4 || retval=$?
	check_duplicate_variables $VARS_IPSETV6 || retval=$?

	# Check for unset variables
	check_datafile_unset_variables $VARS_IPV4 || retval=$?
	check_datafile_unset_variables $VARS_IPV6 || retval=$?
	check_datafile_unset_variables $VARS_IPSETV4 || retval=$?
	check_datafile_unset_variables $VARS_IPSETV6 || retval=$?

	# Check for duplicates variables from one kind of datafiles to another
	check_duplicate_ipset_ip_variables || retval=$?

	return $retval
}

# void get_input_abstracted_of_type(string data, string outputfile)
# Given a data, search datafiles and output results to outputfile.
# No matter what is the type of the data: var, ip, fqdn, whatever.
get_input_abstracted_of_type()
{
	data=$1
	outputfile=$2


	# 1º Search the data just typed
	search_datafiles $data $outputfile


	# 2º Search the variable name the data should has
	variable_name=$( get_variable_name $data )
	if [ $? -eq 0 ] && [ ! -z "$variable_name" ]
	then
		search_datafiles $variable_name $outputfile
	fi

	# Take care of the message format produced by function search_datafiles()
	# /path/to/datafile: VAR=data #text
	# /path/to/datafile: IPSETVAR=data
	if [ `cat $outputfile | wc -l` -gt 0 ]
	then
		oldIFS=$IFS ; IFS=$' \t\n' # Control over IFS
		# Search after comment (#)
		local new_data_search_list=`cat $outputfile | awk -F'#' '{print $2}' | awk -F' ' '{print $1}' | sort -u | uniq `
		[ ! -z "$ne_data_search_list" ] && for i in $new_data_search_list
		do
			search_datafiles $i $outputfile
		done
		# Search before (=)
		local new_data_search_list=`cat $outputfile | awk -F' ' '{print $2}' | awk -F'=' '{print $1}' | sort -u | uniq`
		[ ! -z "$ne_data_search_list" ] && for i in $new_data_search_list
		do
			search_datafiles $i $outputfile
		done
		# Seach after (=)
		local new_data_search_list=`cat $outputfile | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | sort -u | uniq`
		[ ! -z "$ne_data_search_list" ] && for i in $new_data_search_list
		do
			if [ "$i" != "\$VOID" ] || [ "$i" != "\$VOID" ]
			then
				search_datafiles $i $outputfile
			fi
		done
		IFS=$oldIFS
	fi
	return 0
}

# boolean get_information(string data)
# Search for information in datafiles, sets and iptables
get_information()
{

	local get_information_retval=1
        local data=$1
	echo -n "" > $AUX_FILE

        if [ -z "$data" ]
        then
                # No input data, use menu
                read -p "-> Define IPv4, IPv6 or FQDN: " data
        fi

	get_input_abstracted_of_type $data $AUX_FILE
	# Now, in $AUX_FILE we have:
	#	/path/to/datafile: VAR=value #tag
	#	/path/to/datafile: VAR=value #tag
	#	/path/to/datafile: VAR=value #tag
	#	/path/to/datafile: VAR=value #tag
	#	/path/to/datafile: IPSET=value

 	# Querying now ipset
	local list_of_matching_sets=""
	local flag_set_added=0
	local set_list=`$IPSET -L | grep "Name:" | awk -F' ' '{print $2}' | grep -v ^[[:space:]]*$`
	oldIFS=$IFS ; IFS=$' \t\n' # Control over IFS
	for sset in $set_list
	do
		# Searching raw data inserted in fw-admin -i foo
		if $IPSET -T $sset $( string_to_varname $data ) > /dev/null 2> /dev/null
		then
			list_of_matching_sets="$list_of_matching_sets $sset"
			flag_set_added=1
		fi
		if [ $flag_set_added -eq 0 ]
		then
	                # Searching with data behind # from data already found
			for comment_data in $( awk -F'#' '{print $2}' $AUX_FILE | awk -F' ' '{print $1}' | sort -u | uniq )
			do
				if $IPSET -T $sset $( string_to_varname $comment_data ) > /dev/null 2> /dev/null
				then
					list_of_matching_sets="$list_of_matching_sets $sset"
					flag_set_added=1
				fi
			done
		fi
		if [ $flag_set_added -eq 0 ]
		then
			# Seach with data after (=) from data already found
			for real_data in $( awk -F'=' '{print $2}' $AUX_FILE | awk -F'#' '{print $1}' | sort -u | uniq )
			do
				if $IPSET -T $sset $( string_to_varname $real_data ) > /dev/null 2> /dev/null
				then
					list_of_matching_sets="$list_of_matching_sets $sset"
				fi
			done
		fi
	done
	IFS=$oldIFS

	# Show or not sets where data was found
	if [ ! -z "$list_of_matching_sets" ]
	then
		# Fix for printing
		list_of_sets_witch_match=$( echo $list_of_matching_sets | tr ' ' '\n' | grep -v ^[[:space:]]*$ | sort -u | uniq | tr '\n' ' ' )
		echo -e "I: Data ${C_BOLD}$data${C_NORMAL} is in set(s): ${list_of_matching_sets}" >> $AUX_FILE
		flag_data_shown=true
	fi


	#########################################################
	# Ordering
	if [ `cat $AUX_FILE | wc -l` -gt 0 ]
	then
		flag_data_shown=true
		cat $AUX_FILE | sort -u | while read line
		do
			message "$line"
		done
	fi

	local iptables_query=`grep -i $data $VARS_IPV4 | grep -v VOID | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | tr -d [:space:]` # get value
	if is_ipv4_valid $iptables_query
	then
		local rules_num_ipv4_nat=`$IPT_SAVE -t nat | grep "$iptables_query" | wc -l`
		if [ $rules_num_ipv4_nat -gt 0 ]
		then
			message "I: IPv4 (nat) rules: $rules_num_ipv4_nat"
			$IPT_SAVE -c -t nat | grep $iptables_query && flag_data_shown=true
		fi
		local ipv4_rules_num=`$IPT_SAVE | grep "$iptables_query" | wc -l`
		if [ $ipv4_rules_num -gt 0 ]
		then
			message "I: IPv4 rules: $ipv4_rules_num"
			$IPT_SAVE -c | grep $iptables_query && flag_data_shown=true
		fi
	else
		ipv4_rules_num=0
		rules_num_ipv4_nat=0
	fi
	iptables_query=`grep $data $VARS_IPV6 | awk -F'=' '{print $2}' | awk -F'#' '{print $1}' | tr -d [:space:]` # get value
	if is_ipv6_valid $iptables_query
	then
		local ipv6_rules_num=`$IP6T_SAVE | grep "$iptables_query" | wc -l`
		if [ $ipv6_rules_num -gt 0 ]
		then
			message "I: IPv6 rules: $ipv6_rules_num"
			$IP6T_SAVE -c | grep $iptables_query
			flag_data_shown=true
		fi
	else
		ipv6_rules_num=0
	fi


	total_rules=$(( rules_num_ipv4_nat + total_rules ))
	total_rules=$(( total_rules + ipv4_rules_num ))
	total_rules=$(( total_rules + ipv6_rules_num ))
	[ "$total_rules" -gt 0 ] && message "I: ${C_BOLD}${total_rules}${C_NORMAL} related rules found"

	echo -n "" > $AUX_FILE

	if [ ! -z "$list_of_matching_sets" ]
	then
		oldIFS=$IFS ; IFS=$' '
		for i in $list_of_matching_sets
		do
			$IPT_SAVE -c | grep "match\-set" | grep "$i" >> $AUX_FILE && flag_data_shown=true
			$IP6T_SAVE -c | grep "match\-set" | grep "$i" >> $AUX_FILE && flag_data_shown=true
		done
		IFS=$oldIFS
		local total_rules=$( wc -l $AUX_FILE )
		if [ $total_rules -gt 0 ]
		then
			message "I: Rules regarding related sets:"
			cat $AUX_FILE | sort -u | uniq
		fi
	fi


	if [ "$flag_data_shown" != "true" ]
	then
		message "W: No data found"
		get_information_retval=1
	else
		get_information_retval=0
	fi
	return $get_information_retval
}

# boolean search_datafiles(string data, string result_return_file)
# This function search for data in datafiles and return results to a file
search_datafiles()
{
	local search_datafiles_retval=1
	local data=$1
	local result_return_file=$2

	if [ ! -z "$data" ] && [ -e "$result_return_file" ]
	then
		local aux_data=$( string_to_varname $data )
		oldIFS=$IFS ; IFS=$' '
		for datafile in $VARS_IPV4 $VARS_IPV6 $VARS_IPSETV4 $VARS_IPSETV6
		do
			oldIFS=$IFS ; IFS=$'\n' # control over IFS
			for line in $( egrep -i ="$data"[[:space:]]\|"#""$data"\|"$data"[[:space:]]*"="\|"$aux_data"[[:space:]]*"=" $datafile 2>/dev/null )
			do
				search_datafiles_retval=0
				# WARNING! If you change this message, you must change also the function get_information()
				echo -e "$datafile: ${line}" >> $2
			done
			IFS=$oldIFS
		done
		IFS=$oldIFS

	else
		message "E: Function search_datafiles() called with bad arguments."
		do_exit 1
	fi

	return $search_datafiles_retval
}
